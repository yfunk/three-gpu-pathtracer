{"mappings":"IoBmDI,EAAa,EAAO,EACpB,EAAK,EAAO,EACZ,EAAY,EAAU,EAAQ,EAAO,EAGrC,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,GnBtDJ,IAgBA,EACA,EAjBI,EAAU,IAAI,IAgBlB,EAfA,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,EAAQ,GAAG,CAAC,GAC3B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,IAAI,IAAI,EAAS,IAAI,CAAE,EAAS,OAAO,EAAE,QAAQ,EAC1D,C,G,E,Q,S,C,C,C,E,E,E,O,C,a,I,G,I,E,E,QCLA,OAAM,UAAmB,EAAA,iBAAgB,CAExC,YAAa,CAAO,CAAG,CAEtB,KAAK,CAAE,GAEP,IAAI,CAAC,IAAI,CAAG,EAAA,aAAY,AAEzB,CAIA,MAAO,CAAM,CAAG,KAgVX,EAAM,EACN,EA/UJ,IAMC,EAAa,SAAW,CAAe,CAAE,CAAG,EAE3C,OAAS,GAER,KARgB,EAQM,MAAM,AAAI,MAAO,iCAAqC,CAAA,GAAO,EAAA,EACnF,MARiB,EAQM,MAAM,AAAI,MAAO,kCAAsC,CAAA,GAAO,EAAA,EACrF,MARkB,EAQM,MAAM,AAAI,MAAO,sCAA0C,CAAA,GAAO,EAAA,EAC1F,SACwB,MAAM,AAAI,MAAO,m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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/three/examples/jsm/loaders/RGBELoader.js","src/core/MaterialReducer.js","src/core/WebGLPathTracer.js","src/textures/GradientEquirectTexture.js","src/textures/ProceduralEquirectTexture.js","src/materials/fullscreen/ClampedInterpolationMaterial.js","node_modules/three-mesh-bvh/src/workers/ParallelMeshBVHWorker.js","node_modules/three-mesh-bvh/src/workers/utils/WorkerBase.js","node_modules/three-mesh-bvh/src/workers/GenerateMeshBVHWorker.js","node_modules/@parcel/runtime-js/lib/runtime-1c6990855bd7ff8d.js","node_modules/@parcel/runtime-js/lib/helpers/get-worker-url.js","node_modules/@parcel/runtime-js/lib/runtime-c3f6ca7a2f7d9043.js","example/utils/LoaderElement.js","src/materials/MaterialBase.js","src/shader/common/math_functions.glsl.js","src/shader/common/util_functions.glsl.js","src/shader/bsdf/ggx_functions.glsl.js","node_modules/@parcel/runtime-js/lib/runtime-c01a7b5f0c29f791.js","example/viewerTest.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $18c11f3350a906ea$export$f7ad0328861e2f03, (v) => $18c11f3350a906ea$export$f7ad0328861e2f03 = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = new Map();\nfunction $18c11f3350a906ea$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$18c11f3350a906ea$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping.get(id);\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nparcelRegister(\"891vQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"RGBELoader\", () => $5ee05658f4b0e3bf$export$d076a711b55c758a);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\nclass $5ee05658f4b0e3bf$export$d076a711b55c758a extends (0, $ilwiq.DataTextureLoader) {\n    constructor(manager){\n        super(manager);\n        this.type = (0, $ilwiq.HalfFloatType);\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const /* default error routine.  change this to change error handling */ rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n                case rgbe_write_error:\n                    throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n                case rgbe_format_error:\n                    throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n                default:\n                case rgbe_memory_error:\n                    throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n            }\n        }, /* offsets to red, green, and blue components in a data (float) pixel */ //RGBE_DATA_RED = 0,\n        //RGBE_DATA_GREEN = 1,\n        //RGBE_DATA_BLUE = 2,\n        /* number of floats per pixel, use 4 since stored in rgba image format */ //RGBE_DATA_SIZE = 4,\n        /* flags indicating which fields in an rgbe_header_info are valid */ RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/ if (false !== consume) buffer.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, /* minimal header reading.  modify if you want to parse more information */ RGBE_ReadHeader = function(buffer) {\n            // regexes to parse header info fields\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, // RGBE format header struct\n            header = {\n                valid: 0,\n                /* indicate which fields are valid */ string: \"\",\n                /* the actual header string */ comments: \"\",\n                /* comments found in header */ programtype: \"RGBE\",\n                /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */ format: \"\",\n                /* RGBE format, default 32-bit_rle_rgbe */ gamma: 1.0,\n                /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */ exposure: 1.0,\n                /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */ width: 0,\n                height: 0 /* image dimensions, width/height */ \n            };\n            let line, match;\n            if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) rgbe_error(rgbe_read_error, \"no header found\");\n            /* if you want to require the magic token then uncomment the next line */ if (!(match = line.match(magic_token_re))) rgbe_error(rgbe_format_error, \"bad initial token\");\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue; // comment line\n                }\n                if (match = line.match(gamma_re)) header.gamma = parseFloat(match[1]);\n                if (match = line.match(exposure_re)) header.exposure = parseFloat(match[1]);\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1]; //'32-bit_rle_rgbe';\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) rgbe_error(rgbe_format_error, \"missing format specifier\");\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer, w, h) {\n            const scanline_width = w;\n            if (scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n            2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) // return the flat buffer\n            return new Uint8Array(buffer);\n            if (scanline_width !== (buffer[2] << 8 | buffer[3])) rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            // read in each successive scanline\n            while(num_scanlines > 0 && pos < buffer.byteLength){\n                if (pos + 4 > buffer.byteLength) rgbe_error(rgbe_read_error);\n                rgbeStart[0] = buffer[pos++];\n                rgbeStart[1] = buffer[pos++];\n                rgbeStart[2] = buffer[pos++];\n                rgbeStart[3] = buffer[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                // read each of the four channels for the scanline into the buffer\n                // first red, then green, then blue, then exponent\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer.byteLength){\n                    count = buffer[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    if (isEncodedRun) {\n                        // a (encoded) run of the same value\n                        const byteValue = buffer[pos++];\n                        for(let i = 0; i < count; i++)scanline_buffer[ptr++] = byteValue;\n                    //ptr += count;\n                    } else {\n                        // a literal-run\n                        scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                // now convert data from buffer into rgba\n                // first red, then green, then blue, then exponent (alpha)\n                const l = scanline_width; //scanline_buffer.byteLength;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            // clamping to 65504, the maximum representable value in float16\n            destArray[destOffset + 0] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = (0, $ilwiq.DataUtils).toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n        let data, type;\n        let numElements;\n        switch(this.type){\n            case 0, $ilwiq.FloatType:\n                numElements = image_rgba_data.length / 4;\n                const floatArray = new Float32Array(numElements * 4);\n                for(let j = 0; j < numElements; j++)RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                data = floatArray;\n                type = (0, $ilwiq.FloatType);\n                break;\n            case 0, $ilwiq.HalfFloatType:\n                numElements = image_rgba_data.length / 4;\n                const halfArray = new Uint16Array(numElements * 4);\n                for(let j = 0; j < numElements; j++)RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                data = halfArray;\n                type = (0, $ilwiq.HalfFloatType);\n                break;\n            default:\n                throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n        }\n        return {\n            width: w,\n            height: h,\n            data: data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            type: type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case 0, $ilwiq.FloatType:\n                case 0, $ilwiq.HalfFloatType:\n                    texture.colorSpace = (0, $ilwiq.LinearSRGBColorSpace);\n                    texture.minFilter = (0, $ilwiq.LinearFilter);\n                    texture.magFilter = (0, $ilwiq.LinearFilter);\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n\n});\n\nparcelRegister(\"62xhu\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaterialReducer\", () => $465cbee6efe1dae1$export$c80603c061964928);\n// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\nfunction $465cbee6efe1dae1$var$isTypedArray(arr) {\n    return arr.buffer instanceof ArrayBuffer && \"BYTES_PER_ELEMENT\" in arr;\n}\nclass $465cbee6efe1dae1$export$c80603c061964928 {\n    constructor(){\n        const ignoreKeys = new Set();\n        ignoreKeys.add(\"uuid\");\n        this.ignoreKeys = ignoreKeys;\n        this.shareTextures = true;\n        this.textures = [];\n        this.materials = [];\n    }\n    areEqual(objectA, objectB) {\n        const keySet = new Set();\n        const traverseSet = new Set();\n        const ignoreKeys = this.ignoreKeys;\n        const traverse = (a, b)=>{\n            if (a === b) return true;\n            if (a && b && a instanceof Object && b instanceof Object) {\n                if (traverseSet.has(a) || traverseSet.has(b)) throw new Error(\"MaterialReducer: Material is recursive.\");\n                const aIsElement = a instanceof Element;\n                const bIsElement = b instanceof Element;\n                if (aIsElement || bIsElement) {\n                    if (aIsElement !== bIsElement || !(a instanceof Image) || !(b instanceof Image)) return false;\n                    return a.src === b.src;\n                }\n                const aIsImageBitmap = a instanceof ImageBitmap;\n                const bIsImageBitmap = b instanceof ImageBitmap;\n                if (aIsImageBitmap || bIsImageBitmap) return false;\n                if (a.equals) return a.equals(b);\n                const aIsTypedArray = $465cbee6efe1dae1$var$isTypedArray(a);\n                const bIsTypedArray = $465cbee6efe1dae1$var$isTypedArray(b);\n                if (aIsTypedArray || bIsTypedArray) {\n                    if (aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length) return false;\n                    for(let i = 0, l = a.length; i < l; i++){\n                        if (a[i] !== b[i]) return false;\n                    }\n                    return true;\n                }\n                traverseSet.add(a);\n                traverseSet.add(b);\n                keySet.clear();\n                for(const key in a){\n                    if (!a.hasOwnProperty(key) || a[key] instanceof Function || ignoreKeys.has(key)) continue;\n                    keySet.add(key);\n                }\n                for(const key in b){\n                    if (!b.hasOwnProperty(key) || b[key] instanceof Function || ignoreKeys.has(key)) continue;\n                    keySet.add(key);\n                }\n                const keys = Array.from(keySet.values());\n                let result = true;\n                for(const i in keys){\n                    const key = keys[i];\n                    if (ignoreKeys.has(key)) continue;\n                    result = traverse(a[key], b[key]);\n                    if (!result) break;\n                }\n                traverseSet.delete(a);\n                traverseSet.delete(b);\n                return result;\n            }\n            return false;\n        };\n        return traverse(objectA, objectB);\n    }\n    process(object) {\n        const { textures: textures, materials: materials } = this;\n        let replaced = 0;\n        const processMaterial = (material)=>{\n            // Check if another material matches this one\n            let foundMaterial = null;\n            for(const i in materials){\n                const otherMaterial = materials[i];\n                if (this.areEqual(material, otherMaterial)) foundMaterial = otherMaterial;\n            }\n            if (foundMaterial) {\n                replaced++;\n                return foundMaterial;\n            } else {\n                materials.push(material);\n                if (this.shareTextures) // See if there's another texture that matches the ones on this material\n                for(const key in material){\n                    if (!material.hasOwnProperty(key)) continue;\n                    const value = material[key];\n                    if (value && value.isTexture && value.image instanceof Image) {\n                        let foundTexture = null;\n                        for(const i in textures){\n                            const texture = textures[i];\n                            if (this.areEqual(texture, value)) {\n                                foundTexture = texture;\n                                break;\n                            }\n                        }\n                        if (foundTexture) material[key] = foundTexture;\n                        else textures.push(value);\n                    }\n                }\n                return material;\n            }\n        };\n        object.traverse((c)=>{\n            if (c.isMesh && c.material) {\n                const material = c.material;\n                if (Array.isArray(material)) for(let i = 0; i < material.length; i++)material[i] = processMaterial(material[i]);\n                else c.material = processMaterial(material);\n            }\n        });\n        return {\n            replaced: replaced,\n            retained: materials.length\n        };\n    }\n}\n\n});\n\nparcelRegister(\"8mHfG\", function(module, exports) {\n\n$parcel$export(module.exports, \"WebGLPathTracer\", () => $6171edc1778f11e8$export$3a05a7fb86d40d58);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $hWj76 = parcelRequire(\"hWj76\");\n\nvar $hWds8 = parcelRequire(\"hWds8\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $bHiTZ = parcelRequire(\"bHiTZ\");\n\nvar $9wqOU = parcelRequire(\"9wqOU\");\n\nvar $5rCKZ = parcelRequire(\"5rCKZ\");\nfunction $6171edc1778f11e8$var$supportsFloatBlending(renderer) {\n    return renderer.extensions.get(\"EXT_float_blend\");\n}\nconst $6171edc1778f11e8$var$_resolution = new (0, $ilwiq.Vector2)();\nclass $6171edc1778f11e8$export$3a05a7fb86d40d58 {\n    get multipleImportanceSampling() {\n        return Boolean(this._pathTracer.material.defines.FEATURE_MIS);\n    }\n    set multipleImportanceSampling(v) {\n        this._pathTracer.material.setDefine(\"FEATURE_MIS\", v ? 1 : 0);\n    }\n    get transmissiveBounces() {\n        return this._pathTracer.material.transmissiveBounces;\n    }\n    set transmissiveBounces(v) {\n        this._pathTracer.material.transmissiveBounces = v;\n    }\n    get bounces() {\n        return this._pathTracer.material.bounces;\n    }\n    set bounces(v) {\n        this._pathTracer.material.bounces = v;\n    }\n    get filterGlossyFactor() {\n        return this._pathTracer.material.filterGlossyFactor;\n    }\n    set filterGlossyFactor(v) {\n        this._pathTracer.material.filterGlossyFactor = v;\n    }\n    get samples() {\n        return this._pathTracer.samples;\n    }\n    get target() {\n        return this._pathTracer.target;\n    }\n    get tiles() {\n        return this._pathTracer.tiles;\n    }\n    constructor(renderer){\n        // members\n        this._renderer = renderer;\n        this._generator = new (0, $hWj76.PathTracingSceneGenerator)();\n        this._pathTracer = new (0, $hWds8.PathTracingRenderer)(renderer);\n        this._queueReset = false;\n        this._clock = new (0, $ilwiq.Clock)();\n        this._lowResPathTracer = new (0, $hWds8.PathTracingRenderer)(renderer);\n        this._lowResPathTracer.tiles.set(1, 1);\n        this._quad = new (0, $RPVlj.FullScreenQuad)(new (0, $5rCKZ.ClampedInterpolationMaterial)({\n            map: null,\n            transparent: true,\n            blending: (0, $ilwiq.NoBlending),\n            premultipliedAlpha: renderer.getContextAttributes().premultipliedAlpha\n        }));\n        this._materials = null;\n        // options\n        this.renderDelay = 100;\n        this.minSamples = 5;\n        this.fadeDuration = 500;\n        this.enablePathTracing = true;\n        this.pausePathTracing = false;\n        this.dynamicLowRes = false;\n        this.lowResScale = 0.25;\n        this.renderScale = 1;\n        this.synchronizeRenderSize = true;\n        this.rasterizeScene = true;\n        this.renderToCanvas = true;\n        this.textureSize = new (0, $ilwiq.Vector2)(1024, 1024);\n        this.rasterizeSceneCallback = (scene, camera)=>{\n            this._renderer.render(scene, camera);\n        };\n        this.renderToCanvasCallback = (target, renderer, quad)=>{\n            const currentAutoClear = renderer.autoClear;\n            renderer.autoClear = false;\n            quad.render(renderer);\n            renderer.autoClear = currentAutoClear;\n        };\n        // initialize the scene so it doesn't fail\n        this.setScene(new (0, $ilwiq.Scene)(), new (0, $ilwiq.PerspectiveCamera)());\n    }\n    setBVHWorker(worker) {\n        this._generator.setBVHWorker(worker);\n    }\n    setScene(scene, camera, options = {}) {\n        scene.updateMatrixWorld(true);\n        camera.updateMatrixWorld();\n        const generator = this._generator;\n        generator.setObjects(scene);\n        if (this._buildAsync) return generator.generateAsync(options.onProgress).then((result)=>{\n            return this._updateFromResults(scene, camera, result);\n        });\n        else {\n            const result = generator.generate();\n            return this._updateFromResults(scene, camera, result);\n        }\n    }\n    setSceneAsync(...args) {\n        this._buildAsync = true;\n        const result = this.setScene(...args);\n        this._buildAsync = false;\n        return result;\n    }\n    setCamera(camera) {\n        this.camera = camera;\n        this.updateCamera();\n    }\n    updateCamera() {\n        const camera = this.camera;\n        camera.updateMatrixWorld();\n        this._pathTracer.setCamera(camera);\n        this._lowResPathTracer.setCamera(camera);\n        this.reset();\n    }\n    updateMaterials() {\n        const material = this._pathTracer.material;\n        const renderer = this._renderer;\n        const materials = this._materials;\n        const textureSize = this.textureSize;\n        // TODO: reduce texture sources here - we don't want to do this in the\n        // textures array because we need to pass the textures array into the\n        // material target\n        const textures = (0, $9wqOU.getTextures)(materials);\n        material.textures.setTextures(renderer, textures, textureSize.x, textureSize.y);\n        material.materials.updateFrom(materials, textures);\n        this.reset();\n    }\n    updateLights() {\n        const scene = this.scene;\n        const renderer = this._renderer;\n        const material = this._pathTracer.material;\n        const lights = (0, $9wqOU.getLights)(scene);\n        const iesTextures = (0, $9wqOU.getIesTextures)(lights);\n        material.lights.updateFrom(lights, iesTextures);\n        material.iesProfiles.setTextures(renderer, iesTextures);\n        this.reset();\n    }\n    updateEnvironment() {\n        const scene = this.scene;\n        const material = this._pathTracer.material;\n        // update scene background\n        material.backgroundBlur = scene.backgroundBlurriness;\n        material.backgroundIntensity = scene.backgroundIntensity ?? 1;\n        material.backgroundRotation.makeRotationFromEuler(scene.backgroundRotation).invert();\n        if (scene.background === null) {\n            material.backgroundMap = null;\n            material.backgroundAlpha = 0;\n        } else if (scene.background.isColor) {\n            this._colorBackground = this._colorBackground || new (0, $bHiTZ.GradientEquirectTexture)(16);\n            const colorBackground = this._colorBackground;\n            if (!colorBackground.topColor.equals(scene.background)) {\n                // set the texture color\n                colorBackground.topColor.set(scene.background);\n                colorBackground.bottomColor.set(scene.background);\n                colorBackground.update();\n            }\n            // assign to material\n            material.backgroundMap = colorBackground;\n            material.backgroundAlpha = 1;\n        } else {\n            material.backgroundMap = scene.background;\n            material.backgroundAlpha = 1;\n        }\n        // update scene environment\n        material.environmentIntensity = scene.environmentIntensity ?? 1;\n        material.environmentRotation.makeRotationFromEuler(scene.environmentRotation).invert();\n        if (this._previousEnvironment !== scene.environment) {\n            if (scene.environment) // TODO: Consider setting this to the highest supported bit depth by checking for\n            // OES_texture_float_linear or OES_texture_half_float_linear. Requires changes to\n            // the equirect uniform\n            material.envMapInfo.updateFrom(scene.environment);\n            else material.environmentIntensity = 0;\n        }\n        this._previousEnvironment = scene.environment;\n        this.reset();\n    }\n    _updateFromResults(scene, camera, results) {\n        const { materials: materials, geometry: geometry, bvh: bvh, bvhChanged: bvhChanged } = results;\n        this._materials = materials;\n        const pathTracer = this._pathTracer;\n        const material = pathTracer.material;\n        if (bvhChanged) {\n            material.bvh.updateFrom(bvh);\n            material.attributesArray.updateFrom(geometry.attributes.normal, geometry.attributes.tangent, geometry.attributes.uv, geometry.attributes.color);\n            material.materialIndexAttribute.updateFrom(geometry.attributes.materialIndex);\n        }\n        // save previously used items\n        this._previousScene = scene;\n        this.scene = scene;\n        this.camera = camera;\n        this.updateCamera();\n        this.updateMaterials();\n        this.updateEnvironment();\n        this.updateLights();\n        return results;\n    }\n    renderSample() {\n        const lowResPathTracer = this._lowResPathTracer;\n        const pathTracer = this._pathTracer;\n        const renderer = this._renderer;\n        const clock = this._clock;\n        const quad = this._quad;\n        this._updateScale();\n        if (this._queueReset) {\n            pathTracer.reset();\n            lowResPathTracer.reset();\n            this._queueReset = false;\n            quad.material.opacity = 0;\n            clock.start();\n        }\n        // render the path tracing sample after enough time has passed\n        const delta = clock.getDelta() * 1e3;\n        const elapsedTime = clock.getElapsedTime() * 1e3;\n        if (!this.pausePathTracing && this.enablePathTracing && this.renderDelay <= elapsedTime) pathTracer.update();\n        // when alpha is enabled we use a manual blending system rather than\n        // rendering with a blend function\n        pathTracer.alpha = pathTracer.material.backgroundAlpha !== 1 || !$6171edc1778f11e8$var$supportsFloatBlending(renderer);\n        lowResPathTracer.alpha = pathTracer.alpha;\n        if (this.renderToCanvas) {\n            const renderer = this._renderer;\n            const minSamples = this.minSamples;\n            if (elapsedTime >= this.renderDelay && this.samples >= this.minSamples) {\n                if (this.fadeDuration !== 0) quad.material.opacity = Math.min(quad.material.opacity + delta / this.fadeDuration, 1);\n                else quad.material.opacity = 1;\n            }\n            // render the fallback if we haven't rendered enough samples, are paused, or are occluded\n            if (!this.enablePathTracing || this.samples < minSamples || quad.material.opacity < 1) {\n                if (this.dynamicLowRes) {\n                    if (lowResPathTracer.samples < 1) {\n                        lowResPathTracer.material = pathTracer.material;\n                        lowResPathTracer.update();\n                    }\n                    const currentOpacity = quad.material.opacity;\n                    quad.material.opacity = 1 - quad.material.opacity;\n                    quad.material.map = lowResPathTracer.target.texture;\n                    quad.render(renderer);\n                    quad.material.opacity = currentOpacity;\n                } else if (this.rasterizeScene) this.rasterizeSceneCallback(this.scene, this.camera);\n            }\n            if (this.enablePathTracing && quad.material.opacity > 0) {\n                if (quad.material.opacity < 1) // use additive blending when the low res texture is rendered so we can fade the\n                // background out while the full res fades in\n                quad.material.blending = this.dynamicLowRes ? (0, $ilwiq.AdditiveBlending) : (0, $ilwiq.NormalBlending);\n                quad.material.map = pathTracer.target.texture;\n                this.renderToCanvasCallback(pathTracer.target, renderer, quad);\n                quad.material.blending = (0, $ilwiq.NoBlending);\n            }\n        }\n    }\n    reset() {\n        this._queueReset = true;\n        this._pathTracer.samples = 0;\n    }\n    dispose() {\n        this._renderQuad.dispose();\n        this._renderQuad.material.dispose();\n        this._pathTracer.dispose();\n    }\n    _updateScale() {\n        // update the path tracer scale if it has changed\n        if (this.synchronizeRenderSize) {\n            this._renderer.getDrawingBufferSize($6171edc1778f11e8$var$_resolution);\n            const w = Math.floor(this.renderScale * $6171edc1778f11e8$var$_resolution.x);\n            const h = Math.floor(this.renderScale * $6171edc1778f11e8$var$_resolution.y);\n            this._pathTracer.getSize($6171edc1778f11e8$var$_resolution);\n            if ($6171edc1778f11e8$var$_resolution.x !== w || $6171edc1778f11e8$var$_resolution.y !== h) {\n                const lowResScale = this.lowResScale;\n                this._pathTracer.setSize(w, h);\n                this._lowResPathTracer.setSize(Math.floor(w * lowResScale), Math.floor(h * lowResScale));\n            }\n        }\n    }\n}\n\n});\nparcelRegister(\"bHiTZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"GradientEquirectTexture\", () => $88425f7125b6e46c$export$38d6a241e670a287);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $dbdMq = parcelRequire(\"dbdMq\");\nconst $88425f7125b6e46c$var$_direction = new (0, $ilwiq.Vector3)();\nclass $88425f7125b6e46c$export$38d6a241e670a287 extends (0, $dbdMq.ProceduralEquirectTexture) {\n    constructor(resolution = 512){\n        super(resolution, resolution);\n        this.topColor = new (0, $ilwiq.Color)().set(0xffffff);\n        this.bottomColor = new (0, $ilwiq.Color)().set(0x000000);\n        this.exponent = 2;\n        this.generationCallback = (polar, uv, coord, color)=>{\n            $88425f7125b6e46c$var$_direction.setFromSpherical(polar);\n            const t = $88425f7125b6e46c$var$_direction.y * 0.5 + 0.5;\n            color.lerpColors(this.bottomColor, this.topColor, t ** this.exponent);\n        };\n    }\n    copy(other) {\n        super.copy(other);\n        this.topColor.copy(other.topColor);\n        this.bottomColor.copy(other.bottomColor);\n        return this;\n    }\n}\n\n});\nparcelRegister(\"dbdMq\", function(module, exports) {\n\n$parcel$export(module.exports, \"ProceduralEquirectTexture\", () => $9986fde00d79bc96$export$ab88b3c5fea10066);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $9986fde00d79bc96$var$_uv = new (0, $ilwiq.Vector2)();\nconst $9986fde00d79bc96$var$_coord = new (0, $ilwiq.Vector2)();\nconst $9986fde00d79bc96$var$_polar = new (0, $ilwiq.Spherical)();\nconst $9986fde00d79bc96$var$_color = new (0, $ilwiq.Color)();\nclass $9986fde00d79bc96$export$ab88b3c5fea10066 extends (0, $ilwiq.DataTexture) {\n    constructor(width = 512, height = 512){\n        super(new Float32Array(width * height * 4), width, height, (0, $ilwiq.RGBAFormat), (0, $ilwiq.FloatType), (0, $ilwiq.EquirectangularReflectionMapping), (0, $ilwiq.RepeatWrapping), (0, $ilwiq.ClampToEdgeWrapping), (0, $ilwiq.LinearFilter), (0, $ilwiq.LinearFilter));\n        this.generationCallback = null;\n    }\n    update() {\n        this.dispose();\n        this.needsUpdate = true;\n        const { data: data, width: width, height: height } = this.image;\n        for(let x = 0; x < width; x++)for(let y = 0; y < height; y++){\n            $9986fde00d79bc96$var$_coord.set(width, height);\n            $9986fde00d79bc96$var$_uv.set(x / width, y / height);\n            $9986fde00d79bc96$var$_uv.x -= 0.5;\n            $9986fde00d79bc96$var$_uv.y = 1.0 - $9986fde00d79bc96$var$_uv.y;\n            $9986fde00d79bc96$var$_polar.theta = $9986fde00d79bc96$var$_uv.x * 2.0 * Math.PI;\n            $9986fde00d79bc96$var$_polar.phi = $9986fde00d79bc96$var$_uv.y * Math.PI;\n            $9986fde00d79bc96$var$_polar.radius = 1.0;\n            this.generationCallback($9986fde00d79bc96$var$_polar, $9986fde00d79bc96$var$_uv, $9986fde00d79bc96$var$_coord, $9986fde00d79bc96$var$_color);\n            const i = y * width + x;\n            const i4 = 4 * i;\n            data[i4 + 0] = $9986fde00d79bc96$var$_color.r;\n            data[i4 + 1] = $9986fde00d79bc96$var$_color.g;\n            data[i4 + 2] = $9986fde00d79bc96$var$_color.b;\n            data[i4 + 3] = 1.0;\n        }\n    }\n    copy(other) {\n        super.copy(other);\n        this.generationCallback = other.generationCallback;\n        return this;\n    }\n}\n\n});\n\n\nparcelRegister(\"5rCKZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"ClampedInterpolationMaterial\", () => $3f6d89af35c8e149$export$41f50d3add172b7d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $3f6d89af35c8e149$export$41f50d3add172b7d extends (0, $ilwiq.ShaderMaterial) {\n    get map() {\n        return this.uniforms.map.value;\n    }\n    set map(v) {\n        this.uniforms.map.value = v;\n    }\n    get opacity() {\n        return this.uniforms.opacity.value;\n    }\n    set opacity(v) {\n        if (this.uniforms) this.uniforms.opacity.value = v;\n    }\n    constructor(params){\n        super({\n            uniforms: {\n                map: {\n                    value: null\n                },\n                opacity: {\n                    value: 1\n                }\n            },\n            vertexShader: /* glsl */ `\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n            fragmentShader: /* glsl */ `\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float opacity;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec4 clampedTexelFatch( sampler2D map, ivec2 px, int lod ) {\n\n\t\t\t\t\tvec4 res = texelFetch( map, ivec2( px.x, px.y ), 0 );\n\n\t\t\t\t\t#if defined( TONE_MAPPING )\n\n\t\t\t\t\tres.xyz = toneMapping( res.xyz );\n\n\t\t\t\t\t#endif\n\n\t\t\t  \t\treturn linearToOutputTexel( res );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec2 size = vec2( textureSize( map, 0 ) );\n\t\t\t\t\tvec2 pxUv = vUv * size;\n\t\t\t\t\tvec2 pxCurr = floor( pxUv );\n\t\t\t\t\tvec2 pxFrac = fract( pxUv ) - 0.5;\n\t\t\t\t\tvec2 pxOffset;\n\t\t\t\t\tpxOffset.x = pxFrac.x > 0.0 ? 1.0 : - 1.0;\n\t\t\t\t\tpxOffset.y = pxFrac.y > 0.0 ? 1.0 : - 1.0;\n\n\t\t\t\t\tvec2 pxNext = clamp( pxOffset + pxCurr, vec2( 0.0 ), size - 1.0 );\n\t\t\t\t\tvec2 alpha = abs( pxFrac );\n\n\t\t\t\t\tvec4 p1 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tvec4 p2 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxNext.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxNext.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tgl_FragColor = mix( p1, p2, alpha.y );\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n        });\n        this.setValues(params);\n    }\n}\n\n});\n\n\nparcelRegister(\"kqOCM\", function(module, exports) {\n\n$parcel$export(module.exports, \"ParallelMeshBVHWorker\", () => $edfd8156d2dff8d2$export$1369cce09af89668);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6KVZ3 = parcelRequire(\"6KVZ3\");\n\nvar $3ePKg = parcelRequire(\"3ePKg\");\n\nvar $cSOJe = parcelRequire(\"cSOJe\");\n\nvar $a8VBx = parcelRequire(\"a8VBx\");\n\nvar $5Gkg5 = parcelRequire(\"5Gkg5\");\nconst $edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT = typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency : 4;\n\nclass $edfd8156d2dff8d2$var$_ParallelMeshBVHWorker extends (0, $3ePKg.WorkerBase) {\n    constructor(){\n        const worker = new Worker((parcelRequire(\"2tQrc\")));\n        super(worker);\n        this.name = \"ParallelMeshBVHWorker\";\n        this.maxWorkerCount = Math.max($edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT, 4);\n        if (!(0, $cSOJe.isSharedArrayBufferSupported)()) throw new Error(\"ParallelMeshBVHWorker: Shared Array Buffers are not supported.\");\n    }\n    runTask(worker, geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            if (!geometry.index && !options.indirect) (0, $5Gkg5.ensureIndex)(geometry, options);\n            if (geometry.getAttribute(\"position\").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"ParallelMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.\");\n            worker.onerror = (e)=>{\n                reject(new Error(`ParallelMeshBVHWorker: ${e.message}`));\n            };\n            worker.onmessage = (e)=>{\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.serialized) {\n                    const { serialized: serialized, position: position } = data;\n                    const bvh = (0, $6KVZ3.MeshBVH).deserialize(serialized, geometry, {\n                        setIndex: false\n                    });\n                    const boundsOptions = {\n                        setBoundingBox: true,\n                        ...options\n                    };\n                    // we need to replace the arrays because they're neutered entirely by the\n                    // webworker transfer.\n                    geometry.attributes.position.array = position;\n                    if (serialized.index) {\n                        if (geometry.index) geometry.index.array = serialized.index;\n                        else {\n                            const newIndex = new (0, $ilwiq.BufferAttribute)(serialized.index, 1, false);\n                            geometry.setIndex(newIndex);\n                        }\n                    }\n                    if (boundsOptions.setBoundingBox) geometry.boundingBox = bvh.getBoundingBox(new (0, $ilwiq.Box3)());\n                    if (options.onProgress) options.onProgress(data.progress);\n                    resolve(bvh);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array : null;\n            const position = geometry.attributes.position.array;\n            worker.postMessage({\n                operation: \"BUILD_BVH\",\n                maxWorkerCount: this.maxWorkerCount,\n                index: (0, $cSOJe.convertToBufferType)(index, SharedArrayBuffer),\n                position: (0, $cSOJe.convertToBufferType)(position, SharedArrayBuffer),\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress),\n                    groups: [\n                        ...geometry.groups\n                    ]\n                }\n            });\n        });\n    }\n}\nclass $edfd8156d2dff8d2$export$1369cce09af89668 {\n    constructor(){\n        if ((0, $cSOJe.isSharedArrayBufferSupported)()) return new $edfd8156d2dff8d2$var$_ParallelMeshBVHWorker();\n        else {\n            console.warn(\"ParallelMeshBVHWorker: SharedArrayBuffers not supported. Falling back to single-threaded GenerateMeshBVHWorker.\");\n            const object = new (0, $a8VBx.GenerateMeshBVHWorker)();\n            object.maxWorkerCount = $edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT;\n            return object;\n        }\n    }\n}\n\n});\nparcelRegister(\"3ePKg\", function(module, exports) {\n\n$parcel$export(module.exports, \"WorkerBase\", () => $25bad171b6c71f9d$export$8dbf7c43841b75b7);\nclass $25bad171b6c71f9d$export$8dbf7c43841b75b7 {\n    constructor(worker){\n        this.name = \"WorkerBase\";\n        this.running = false;\n        this.worker = worker;\n        this.worker.onerror = (e)=>{\n            if (e.message) throw new Error(`${this.name}: Could not create Web Worker with error \"${e.message}\"`);\n            else throw new Error(`${this.name}: Could not create Web Worker.`);\n        };\n    }\n    runTask() {}\n    generate(...args) {\n        if (this.running) throw new Error(\"GenerateMeshBVHWorker: Already running job.\");\n        if (this.worker === null) throw new Error(\"GenerateMeshBVHWorker: Worker has been disposed.\");\n        this.running = true;\n        const promise = this.runTask(this.worker, ...args);\n        promise.finally(()=>{\n            this.running = false;\n        });\n        return promise;\n    }\n    dispose() {\n        this.worker.terminate();\n        this.worker = null;\n    }\n}\n\n});\n\nparcelRegister(\"a8VBx\", function(module, exports) {\n\n$parcel$export(module.exports, \"GenerateMeshBVHWorker\", () => $762755cd5891d020$export$426cc6213ad628cf);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6KVZ3 = parcelRequire(\"6KVZ3\");\n\nvar $3ePKg = parcelRequire(\"3ePKg\");\n\nclass $762755cd5891d020$export$426cc6213ad628cf extends (0, $3ePKg.WorkerBase) {\n    constructor(){\n        const worker = new Worker((parcelRequire(\"jVRlM\")));\n        super(worker);\n        this.name = \"GenerateMeshBVHWorker\";\n    }\n    runTask(worker, geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            if (geometry.getAttribute(\"position\").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.\");\n            worker.onerror = (e)=>{\n                reject(new Error(`GenerateMeshBVHWorker: ${e.message}`));\n            };\n            worker.onmessage = (e)=>{\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.serialized) {\n                    const { serialized: serialized, position: position } = data;\n                    const bvh = (0, $6KVZ3.MeshBVH).deserialize(serialized, geometry, {\n                        setIndex: false\n                    });\n                    const boundsOptions = Object.assign({\n                        setBoundingBox: true\n                    }, options);\n                    // we need to replace the arrays because they're neutered entirely by the\n                    // webworker transfer.\n                    geometry.attributes.position.array = position;\n                    if (serialized.index) {\n                        if (geometry.index) geometry.index.array = serialized.index;\n                        else {\n                            const newIndex = new (0, $ilwiq.BufferAttribute)(serialized.index, 1, false);\n                            geometry.setIndex(newIndex);\n                        }\n                    }\n                    if (boundsOptions.setBoundingBox) geometry.boundingBox = bvh.getBoundingBox(new (0, $ilwiq.Box3)());\n                    if (options.onProgress) options.onProgress(data.progress);\n                    resolve(bvh);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array : null;\n            const position = geometry.attributes.position.array;\n            const transferable = [\n                position\n            ];\n            if (index) transferable.push(index);\n            worker.postMessage({\n                index: index,\n                position: position,\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress),\n                    groups: [\n                        ...geometry.groups\n                    ]\n                }\n            }, transferable.map((arr)=>arr.buffer).filter((v)=>typeof SharedArrayBuffer === \"undefined\" || !(v instanceof SharedArrayBuffer)));\n        });\n    }\n}\n\n});\nparcelRegister(\"jVRlM\", function(module, exports) {\n\nvar $7ryUf = parcelRequire(\"7ryUf\");\nlet $e82cb97686acadc5$var$url = new URL(\"generateMeshBVH.worker.373f3c58.js\", import.meta.url);\nmodule.exports = $7ryUf($e82cb97686acadc5$var$url.toString(), $e82cb97686acadc5$var$url.origin, true);\n\n});\nparcelRegister(\"7ryUf\", function(module, exports) {\n\"use strict\";\nmodule.exports = function(workerUrl, origin, isESM) {\n    if (origin === self.location.origin) // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n    else {\n        // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n        var source = isESM ? \"import \" + JSON.stringify(workerUrl) + \";\" : \"importScripts(\" + JSON.stringify(workerUrl) + \");\";\n        return URL.createObjectURL(new Blob([\n            source\n        ], {\n            type: \"application/javascript\"\n        }));\n    }\n};\n\n});\n\n\n\nparcelRegister(\"2tQrc\", function(module, exports) {\n\nvar $7ryUf = parcelRequire(\"7ryUf\");\nlet $1ce6f7437f671131$var$url = new URL(\"parallelMeshBVH.worker.22cf4bb0.js\", import.meta.url);\nmodule.exports = $7ryUf($1ce6f7437f671131$var$url.toString(), $1ce6f7437f671131$var$url.origin, true);\n\n});\n\n\nparcelRegister(\"e2Pv4\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderElement\", () => $a399336cf50451da$export$c2252eb3bc5ad0b7);\nlet $a399336cf50451da$var$_styleElement;\nfunction $a399336cf50451da$var$initializeStyles() {\n    if ($a399336cf50451da$var$_styleElement) return;\n    $a399336cf50451da$var$_styleElement = document.createElement(\"style\");\n    $a399336cf50451da$var$_styleElement.textContent = /* css */ `\n\n\t\t.loader-container, .description {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\tfont-family: 'Courier New', Courier, monospace;\n\t\t\tcolor: white;\n\t\t\tfont-weight: light;\n\t\t\talign-items: flex-start;\n\t\t\tfont-size: 14px;\n\t\t\tpointer-events: none;\n\t\t\tuser-select: none;\n\t\t}\n\n\t\t.loader-container {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t.description {\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t\tpadding: 5px 0;\n\t\t}\n\n\t\t.loader-container .bar {\n\t\t\theight: 2px;\n\t\t\tbackground: white;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.loader-container .credits,\n\t\t.loader-container .samples,\n\t\t.loader-container .percentage {\n\t\t\tpadding: 5px;\n\t\t\tmargin: 0 0 1px 1px;\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\n\t\t\tborder-radius: 2px;\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t.loader-container:not(.loading) .bar,\n\t\t.loader-container:not(.loading) .percentage,\n\t\t.loader-container.loading .credits,\n\t\t.loader-container.loading .samples,\n\t\t.loader-container .credits:empty {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t.loader-container .credits a,\n\t\t.loader-container .credits,\n\t\t.loader-container .samples {\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\n\t\t}\n\t`;\n    document.head.appendChild($a399336cf50451da$var$_styleElement);\n}\nclass $a399336cf50451da$export$c2252eb3bc5ad0b7 {\n    constructor(){\n        $a399336cf50451da$var$initializeStyles();\n        const container = document.createElement(\"div\");\n        container.classList.add(\"loader-container\");\n        const percentageEl = document.createElement(\"div\");\n        percentageEl.classList.add(\"percentage\");\n        container.appendChild(percentageEl);\n        const samplesEl = document.createElement(\"div\");\n        samplesEl.classList.add(\"samples\");\n        container.appendChild(samplesEl);\n        const creditsEl = document.createElement(\"div\");\n        creditsEl.classList.add(\"credits\");\n        container.appendChild(creditsEl);\n        const loaderBarEl = document.createElement(\"div\");\n        loaderBarEl.classList.add(\"bar\");\n        container.appendChild(loaderBarEl);\n        const descriptionEl = document.createElement(\"div\");\n        descriptionEl.classList.add(\"description\");\n        container.appendChild(descriptionEl);\n        this._description = descriptionEl;\n        this._loaderBar = loaderBarEl;\n        this._percentage = percentageEl;\n        this._credits = creditsEl;\n        this._samples = samplesEl;\n        this._container = container;\n        this.setPercentage(0);\n    }\n    attach(container) {\n        container.appendChild(this._container);\n        container.appendChild(this._description);\n    }\n    setPercentage(perc) {\n        this._loaderBar.style.width = `${perc * 100}%`;\n        if (perc === 0) this._percentage.innerText = \"Loading...\";\n        else this._percentage.innerText = `${(perc * 100).toFixed(0)}%`;\n        if (perc >= 1) this._container.classList.remove(\"loading\");\n        else this._container.classList.add(\"loading\");\n    }\n    setSamples(count) {\n        this._samples.innerText = `${Math.floor(count)} samples`;\n    }\n    setCredits(credits) {\n        this._credits.innerHTML = credits;\n    }\n    setDescription(description) {\n        this._description.innerHTML = description;\n    }\n}\n\n});\n\nparcelRegister(\"9fZ6X\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaterialBase\", () => $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d extends (0, $ilwiq.ShaderMaterial) {\n    constructor(shader){\n        super(shader);\n        for(const key in this.uniforms)Object.defineProperty(this, key, {\n            get () {\n                return this.uniforms[key].value;\n            },\n            set (v) {\n                this.uniforms[key].value = v;\n            }\n        });\n    }\n    // sets the given named define value and sets \"needsUpdate\" to true if it's different\n    setDefine(name, value) {\n        if (value === undefined || value === null) {\n            if (name in this.defines) {\n                delete this.defines[name];\n                this.needsUpdate = true;\n                return true;\n            }\n        } else if (this.defines[name] !== value) {\n            this.defines[name] = value;\n            this.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"fYvb1\", function(module, exports) {\n\n$parcel$export(module.exports, \"math_functions\", () => $ba14a4aaa0cde19b$export$98323a006d35be35);\nconst $ba14a4aaa0cde19b$export$98323a006d35be35 = /* glsl */ `\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n\n});\n\nparcelRegister(\"dUUQZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"util_functions\", () => $a21c9b4177584031$export$fe1d788deccfbee3);\nconst $a21c9b4177584031$export$fe1d788deccfbee3 = /* glsl */ `\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n\n});\n\nparcelRegister(\"8keuf\", function(module, exports) {\n\n$parcel$export(module.exports, \"ggx_functions\", () => $60fb6dc3c6495c33$export$4c711108e2e8ef5e);\nconst $60fb6dc3c6495c33$export$4c711108e2e8ef5e = /* glsl */ `\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n\n});\n\nvar $05eff4c0488f598d$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(new URL(\"\", import.meta.url).toString(), JSON.parse('[\"bTBll\",\"viewerTest.daf0f9c0.js\",\"512E4\",\"parallelMeshBVH.worker.22cf4bb0.js\",\"9P1cE\",\"generateMeshBVH.worker.cd4b9fc6.js\",\"lWWke\",\"generateMeshBVH.worker.373f3c58.js\",\"9P1cE\",\"generateMeshBVH.worker.cd4b9fc6.js\",\"jwbL2\",\"aoRender.e5303912.js\",\"63CMm\",\"aoRender.a1271ff5.js\",\"2tzBs\",\"aoRender.89c1b67b.js\",\"6UuCC\",\"aoRender.5fc59dbe.js\",\"6mMEU\",\"aoRender.fc8349f1.js\",\"i0zVc\",\"aoRender.dcf40b33.js\",\"j19h5\",\"aoRender.e8b1599c.js\",\"eif6c\",\"areaLight.5654e8b2.js\"]'));\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\n\nvar $891vQ = parcelRequire(\"891vQ\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $62xhu = parcelRequire(\"62xhu\");\nvar $8mHfG = parcelRequire(\"8mHfG\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $kqOCM = parcelRequire(\"kqOCM\");\n\nvar $e2Pv4 = parcelRequire(\"e2Pv4\");\nconst $f6c83a1fcfd19596$var$CONFIG_URL = \"https://raw.githubusercontent.com/google/model-viewer/master/packages/render-fidelity-tools/test/config.json\";\nconst $f6c83a1fcfd19596$var$BASE_URL = \"https://raw.githubusercontent.com/google/model-viewer/master/packages/render-fidelity-tools/test/config/\";\nconst $f6c83a1fcfd19596$var$urlParams = new URLSearchParams(window.location.search);\nconst $f6c83a1fcfd19596$var$maxSamples = parseInt($f6c83a1fcfd19596$var$urlParams.get(\"samples\")) || -1;\nconst $f6c83a1fcfd19596$var$hideUI = $f6c83a1fcfd19596$var$urlParams.get(\"hideUI\") === \"true\";\nconst $f6c83a1fcfd19596$var$tiles = parseInt($f6c83a1fcfd19596$var$urlParams.get(\"tiles\")) || 2;\nconst $f6c83a1fcfd19596$var$scale = parseInt($f6c83a1fcfd19596$var$urlParams.get(\"scale\")) || 1 / window.devicePixelRatio;\nconst $f6c83a1fcfd19596$var$params = {\n    enable: true,\n    bounces: 10,\n    transmissiveBounces: 10,\n    pause: false,\n    multipleImportanceSampling: true,\n    acesToneMapping: true,\n    tiles: $f6c83a1fcfd19596$var$tiles,\n    scale: $f6c83a1fcfd19596$var$scale,\n    model: \"\",\n    checkerboardTransparency: true,\n    displayImage: false,\n    imageMode: \"overlay\",\n    imageOpacity: 1.0,\n    imageType: \"dspbr-pt\"\n};\nlet $f6c83a1fcfd19596$var$containerEl, $f6c83a1fcfd19596$var$imgEl, $f6c83a1fcfd19596$var$loader;\nlet $f6c83a1fcfd19596$var$gui, $f6c83a1fcfd19596$var$model, $f6c83a1fcfd19596$var$envMap;\nlet $f6c83a1fcfd19596$var$pathTracer, $f6c83a1fcfd19596$var$renderer, $f6c83a1fcfd19596$var$camera, $f6c83a1fcfd19596$var$scene, $f6c83a1fcfd19596$var$controls;\nlet $f6c83a1fcfd19596$var$loadingModel = false;\nlet $f6c83a1fcfd19596$var$delaySamples = 0;\nlet $f6c83a1fcfd19596$var$modelDatabase;\n$f6c83a1fcfd19596$var$init();\nasync function $f6c83a1fcfd19596$var$init() {\n    // get elements\n    $f6c83a1fcfd19596$var$containerEl = document.getElementById(\"container\");\n    $f6c83a1fcfd19596$var$imgEl = document.querySelector(\"img\");\n    if ($f6c83a1fcfd19596$var$hideUI) {\n        $f6c83a1fcfd19596$var$containerEl.style.background = \"transparent\";\n        document.body.style.background = \"transparent\";\n    }\n    $f6c83a1fcfd19596$var$loader = new (0, $e2Pv4.LoaderElement)();\n    if (!$f6c83a1fcfd19596$var$hideUI) $f6c83a1fcfd19596$var$loader.attach(document.body);\n    // renderer\n    $f6c83a1fcfd19596$var$renderer = new (0, $ilwiq.WebGLRenderer)({\n        antialias: true,\n        preserveDrawingBuffer: true\n    });\n    $f6c83a1fcfd19596$var$renderer.physicallyCorrectLights = true;\n    $f6c83a1fcfd19596$var$renderer.toneMapping = (0, $ilwiq.ACESFilmicToneMapping);\n    $f6c83a1fcfd19596$var$renderer.setClearAlpha(0);\n    $f6c83a1fcfd19596$var$containerEl.appendChild($f6c83a1fcfd19596$var$renderer.domElement);\n    // path tracer\n    $f6c83a1fcfd19596$var$pathTracer = new (0, $8mHfG.WebGLPathTracer)($f6c83a1fcfd19596$var$renderer);\n    $f6c83a1fcfd19596$var$pathTracer.filterGlossyFactor = 0.5;\n    $f6c83a1fcfd19596$var$pathTracer.tiles.set($f6c83a1fcfd19596$var$params.tiles);\n    $f6c83a1fcfd19596$var$pathTracer.setBVHWorker(new (0, $kqOCM.ParallelMeshBVHWorker)());\n    $f6c83a1fcfd19596$var$pathTracer.multipleImportanceSampling = $f6c83a1fcfd19596$var$params.multipleImportanceSampling;\n    // scene\n    $f6c83a1fcfd19596$var$scene = new (0, $ilwiq.Scene)();\n    // init camera\n    const aspect = window.innerWidth / window.innerHeight;\n    $f6c83a1fcfd19596$var$camera = new (0, $ilwiq.PerspectiveCamera)(60, aspect, 0.01, 500);\n    $f6c83a1fcfd19596$var$camera.position.set(-1, 0.25, 1);\n    // controls\n    $f6c83a1fcfd19596$var$controls = new (0, $5Rd1x.OrbitControls)($f6c83a1fcfd19596$var$camera, $f6c83a1fcfd19596$var$containerEl);\n    $f6c83a1fcfd19596$var$controls.addEventListener(\"change\", ()=>$f6c83a1fcfd19596$var$pathTracer.updateCamera());\n    // models\n    const { scenarios: scenarios } = await fetch($f6c83a1fcfd19596$var$CONFIG_URL).then((res)=>res.json());\n    $f6c83a1fcfd19596$var$modelDatabase = {};\n    scenarios.forEach((s)=>$f6c83a1fcfd19596$var$modelDatabase[s.name] = s);\n    window.addEventListener(\"hashchange\", $f6c83a1fcfd19596$var$onHashChange);\n    $f6c83a1fcfd19596$var$onHashChange();\n    $f6c83a1fcfd19596$var$animate();\n}\nfunction $f6c83a1fcfd19596$var$animate() {\n    requestAnimationFrame($f6c83a1fcfd19596$var$animate);\n    // if rendering has completed then don't render\n    if ($f6c83a1fcfd19596$var$pathTracer.samples >= $f6c83a1fcfd19596$var$maxSamples && $f6c83a1fcfd19596$var$maxSamples !== -1) return;\n    $f6c83a1fcfd19596$var$imgEl.style.display = !$f6c83a1fcfd19596$var$params.displayImage ? \"none\" : \"inline-block\";\n    $f6c83a1fcfd19596$var$imgEl.style.opacity = $f6c83a1fcfd19596$var$params.imageMode === \"side-by-side\" ? 1.0 : $f6c83a1fcfd19596$var$params.imageOpacity;\n    $f6c83a1fcfd19596$var$imgEl.style.position = $f6c83a1fcfd19596$var$params.imageMode === \"side-by-side\" ? \"initial\" : \"absolute\";\n    $f6c83a1fcfd19596$var$imgEl.style.width = $f6c83a1fcfd19596$var$renderer.domElement.style.width;\n    $f6c83a1fcfd19596$var$imgEl.style.height = $f6c83a1fcfd19596$var$renderer.domElement.style.height;\n    if ($f6c83a1fcfd19596$var$loadingModel) return;\n    // TODO: use a delay field from WebGLPathTracer\n    if ($f6c83a1fcfd19596$var$params.enable && $f6c83a1fcfd19596$var$delaySamples === 0) {\n        $f6c83a1fcfd19596$var$pathTracer.enablePathTracing = $f6c83a1fcfd19596$var$params.enable;\n        $f6c83a1fcfd19596$var$pathTracer.pausePathTracing = $f6c83a1fcfd19596$var$params.pause || $f6c83a1fcfd19596$var$pathTracer.samples > $f6c83a1fcfd19596$var$maxSamples && $f6c83a1fcfd19596$var$maxSamples !== -1;\n        $f6c83a1fcfd19596$var$pathTracer.renderSample();\n    } else if ($f6c83a1fcfd19596$var$delaySamples > 0 || !$f6c83a1fcfd19596$var$params.enable) {\n        $f6c83a1fcfd19596$var$delaySamples = Math.max($f6c83a1fcfd19596$var$delaySamples - 1, 0);\n        $f6c83a1fcfd19596$var$renderer.render($f6c83a1fcfd19596$var$scene, $f6c83a1fcfd19596$var$camera);\n    }\n    // rendering has completed\n    if ($f6c83a1fcfd19596$var$pathTracer.samples >= $f6c83a1fcfd19596$var$maxSamples && $f6c83a1fcfd19596$var$maxSamples !== -1) requestAnimationFrame(()=>window.dispatchEvent(new Event(\"render-complete\")));\n    $f6c83a1fcfd19596$var$loader.setSamples($f6c83a1fcfd19596$var$pathTracer.samples);\n}\nfunction $f6c83a1fcfd19596$var$onHashChange() {\n    $f6c83a1fcfd19596$var$params.model = Object.keys($f6c83a1fcfd19596$var$modelDatabase)[0];\n    if (window.location.hash) {\n        const modelName = window.location.hash.substring(1).replaceAll(\"%20\", \" \");\n        if (modelName in $f6c83a1fcfd19596$var$modelDatabase) $f6c83a1fcfd19596$var$params.model = modelName;\n    }\n    $f6c83a1fcfd19596$var$updateModel();\n}\nfunction $f6c83a1fcfd19596$var$onParamsChange() {\n    if ($f6c83a1fcfd19596$var$pathTracer.tiles !== 1.0) $f6c83a1fcfd19596$var$delaySamples = 1;\n    if ($f6c83a1fcfd19596$var$params.checkerboardTransparency) $f6c83a1fcfd19596$var$containerEl.classList.add(\"checkerboard\");\n    else $f6c83a1fcfd19596$var$containerEl.classList.remove(\"checkerboard\");\n    $f6c83a1fcfd19596$var$pathTracer.multipleImportanceSampling = $f6c83a1fcfd19596$var$params.multipleImportanceSampling;\n    $f6c83a1fcfd19596$var$pathTracer.bounces = $f6c83a1fcfd19596$var$params.bounces;\n    $f6c83a1fcfd19596$var$pathTracer.transmissiveBounces = $f6c83a1fcfd19596$var$params.transmissiveBounces;\n    $f6c83a1fcfd19596$var$pathTracer.renderScale = $f6c83a1fcfd19596$var$params.scale;\n    const model = $f6c83a1fcfd19596$var$modelDatabase[$f6c83a1fcfd19596$var$params.model];\n    $f6c83a1fcfd19596$var$scene.background = model && model.renderSkybox ? $f6c83a1fcfd19596$var$scene.environment : null;\n    $f6c83a1fcfd19596$var$pathTracer.updateEnvironment();\n}\nfunction $f6c83a1fcfd19596$var$buildGui() {\n    if ($f6c83a1fcfd19596$var$hideUI) return;\n    if ($f6c83a1fcfd19596$var$gui) $f6c83a1fcfd19596$var$gui.destroy();\n    $f6c83a1fcfd19596$var$gui = new (0, $jiuw3.GUI)();\n    $f6c83a1fcfd19596$var$gui.add($f6c83a1fcfd19596$var$params, \"model\", Object.keys($f6c83a1fcfd19596$var$modelDatabase)).onChange((v)=>{\n        window.location.hash = v;\n    });\n    const pathTracingFolder = $f6c83a1fcfd19596$var$gui.addFolder(\"Path Tracer\");\n    pathTracingFolder.add($f6c83a1fcfd19596$var$params, \"enable\");\n    pathTracingFolder.add($f6c83a1fcfd19596$var$params, \"pause\");\n    pathTracingFolder.add($f6c83a1fcfd19596$var$params, \"scale\", 0.1, 1).onChange($f6c83a1fcfd19596$var$onParamsChange);\n    pathTracingFolder.add($f6c83a1fcfd19596$var$params, \"multipleImportanceSampling\").onChange($f6c83a1fcfd19596$var$onParamsChange);\n    pathTracingFolder.add($f6c83a1fcfd19596$var$params, \"acesToneMapping\").onChange((v)=>{\n        $f6c83a1fcfd19596$var$renderer.toneMapping = v ? (0, $ilwiq.ACESFilmicToneMapping) : (0, $ilwiq.NoToneMapping);\n    });\n    pathTracingFolder.add($f6c83a1fcfd19596$var$params, \"tiles\", 1, 10, 1).onChange((v)=>{\n        $f6c83a1fcfd19596$var$pathTracer.tiles.set(v, v);\n    });\n    pathTracingFolder.add($f6c83a1fcfd19596$var$params, \"bounces\", 1, 20, 1).onChange($f6c83a1fcfd19596$var$onParamsChange);\n    pathTracingFolder.add($f6c83a1fcfd19596$var$params, \"transmissiveBounces\", 1, 20, 1).onChange($f6c83a1fcfd19596$var$onParamsChange);\n    const comparisonFolder = $f6c83a1fcfd19596$var$gui.addFolder(\"Comparison\");\n    comparisonFolder.add($f6c83a1fcfd19596$var$params, \"displayImage\");\n    comparisonFolder.add($f6c83a1fcfd19596$var$params, \"imageMode\", [\n        \"overlay\",\n        \"side-by-side\"\n    ]);\n    comparisonFolder.add($f6c83a1fcfd19596$var$params, \"imageType\", [\n        \"dspbr-pt\",\n        \"filament\",\n        \"babylon\",\n        \"gltf-sample-viewer\",\n        \"model-viewer\",\n        \"rhodonite\",\n        \"stellar\"\n    ]).onChange($f6c83a1fcfd19596$var$updateImage);\n    comparisonFolder.add($f6c83a1fcfd19596$var$params, \"imageOpacity\", 0, 1.0);\n    comparisonFolder.add($f6c83a1fcfd19596$var$params, \"checkerboardTransparency\").onChange($f6c83a1fcfd19596$var$onParamsChange);\n}\nasync function $f6c83a1fcfd19596$var$updateModel() {\n    // dispose of a gui\n    if ($f6c83a1fcfd19596$var$gui) {\n        $f6c83a1fcfd19596$var$containerEl.classList.remove(\"checkerboard\");\n        $f6c83a1fcfd19596$var$gui.destroy();\n        $f6c83a1fcfd19596$var$gui = null;\n    }\n    // dispose of everything\n    if ($f6c83a1fcfd19596$var$model) {\n        $f6c83a1fcfd19596$var$model.traverse((c)=>{\n            if (c.material) {\n                const material = c.material;\n                for(const key in material)if (material[key] && material[key].isTexture) material[key].dispose();\n            }\n        });\n        $f6c83a1fcfd19596$var$scene.remove($f6c83a1fcfd19596$var$model);\n    }\n    // dispose of the background\n    if ($f6c83a1fcfd19596$var$envMap) $f6c83a1fcfd19596$var$envMap.dispose();\n    const modelInfo = $f6c83a1fcfd19596$var$modelDatabase[$f6c83a1fcfd19596$var$params.model];\n    const { verticalFoV: verticalFoV = 45, lighting: lighting = \"../../../shared-assets/environments/lightroom_14b.hdr\" } = modelInfo;\n    let { orbit: orbit = {}, target: target = {}, dimensions: dimensions = {} } = modelInfo;\n    orbit = {\n        theta: 0,\n        phi: 90,\n        radius: 1,\n        ...orbit\n    };\n    target = {\n        x: 0,\n        y: 0,\n        z: 0,\n        ...target\n    };\n    dimensions = {\n        width: 768,\n        height: 768,\n        ...dimensions\n    };\n    // add a minimal radius so the camera orientation is correct when radius is 0\n    orbit.radius = Math.max(orbit.radius, 1e-5);\n    $f6c83a1fcfd19596$var$loadingModel = true;\n    $f6c83a1fcfd19596$var$containerEl.style.display = \"none\";\n    // load assets\n    const envUrl = new URL(lighting, $f6c83a1fcfd19596$var$BASE_URL).toString();\n    const modelUrl = new URL(modelInfo.model, $f6c83a1fcfd19596$var$BASE_URL).toString().replace(/.*?glTF-Sample-Assets/, \"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main\");\n    const manager = new (0, $ilwiq.LoadingManager)();\n    const [envTexture, gltf] = await Promise.all([\n        new (0, $891vQ.RGBELoader)(manager).loadAsync(envUrl),\n        new (0, $7lx9d.GLTFLoader)(manager).setMeshoptDecoder((0, $kp7Te.MeshoptDecoder)).loadAsync(modelUrl, (progress)=>{\n            if (progress.total !== 0 && progress.total >= progress.loaded) $f6c83a1fcfd19596$var$loader.setPercentage(0.5 * progress.loaded / progress.total);\n        }),\n        new Promise((resolve)=>manager.onLoad = resolve)\n    ]);\n    $f6c83a1fcfd19596$var$envMap = envTexture;\n    $f6c83a1fcfd19596$var$envMap.mapping = (0, $ilwiq.EquirectangularReflectionMapping);\n    $f6c83a1fcfd19596$var$scene.environment = $f6c83a1fcfd19596$var$envMap;\n    $f6c83a1fcfd19596$var$model = gltf.scene;\n    // reduce the used materials\n    const reducer = new (0, $62xhu.MaterialReducer)();\n    reducer.process($f6c83a1fcfd19596$var$model);\n    const targetsToDisconnect = [];\n    $f6c83a1fcfd19596$var$model.traverse((c)=>{\n        if (c.isLight && c.target) targetsToDisconnect.push(c.target);\n    });\n    // disconnect all light targets from parents because that's what happens after a clone which\n    // is needed to match the model viewer setup\n    targetsToDisconnect.forEach((t)=>t.removeFromParent());\n    // add a parent group to process the parent offset\n    const targetGroup = new (0, $ilwiq.Group)();\n    targetGroup.position.set(-target.x, -target.y, -target.z);\n    targetGroup.add($f6c83a1fcfd19596$var$model);\n    // replace the target group TODO\n    $f6c83a1fcfd19596$var$model = targetGroup;\n    $f6c83a1fcfd19596$var$model.updateMatrixWorld(true);\n    $f6c83a1fcfd19596$var$scene.add($f6c83a1fcfd19596$var$model);\n    const box = new (0, $ilwiq.Box3)();\n    const sphere = new (0, $ilwiq.Sphere)();\n    box.setFromObject($f6c83a1fcfd19596$var$model);\n    box.getBoundingSphere(sphere);\n    // mirror the model-viewer near / far planes\n    const radius = Math.max(orbit.radius, sphere.radius);\n    $f6c83a1fcfd19596$var$camera.near = 2 * radius / 1000;\n    $f6c83a1fcfd19596$var$camera.far = 2 * radius;\n    $f6c83a1fcfd19596$var$camera.updateProjectionMatrix();\n    $f6c83a1fcfd19596$var$camera.position.setFromSphericalCoords(orbit.radius, (0, $ilwiq.MathUtils).DEG2RAD * orbit.phi, (0, $ilwiq.MathUtils).DEG2RAD * orbit.theta);\n    // initialize the canvas size\n    const { width: width, height: height } = dimensions;\n    $f6c83a1fcfd19596$var$renderer.setSize(width, height);\n    $f6c83a1fcfd19596$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $f6c83a1fcfd19596$var$camera.aspect = width / height;\n    $f6c83a1fcfd19596$var$camera.fov = verticalFoV;\n    $f6c83a1fcfd19596$var$camera.updateProjectionMatrix();\n    $f6c83a1fcfd19596$var$controls.update();\n    await $f6c83a1fcfd19596$var$pathTracer.setSceneAsync($f6c83a1fcfd19596$var$scene, $f6c83a1fcfd19596$var$camera, {\n        onProgress: (v)=>{\n            $f6c83a1fcfd19596$var$loader.setPercentage(0.5 + 0.5 * v);\n        }\n    });\n    $f6c83a1fcfd19596$var$loader.setCredits(modelInfo.credit || \"\");\n    $f6c83a1fcfd19596$var$containerEl.style.display = \"flex\";\n    $f6c83a1fcfd19596$var$loadingModel = false;\n    $f6c83a1fcfd19596$var$onParamsChange();\n    $f6c83a1fcfd19596$var$buildGui();\n    $f6c83a1fcfd19596$var$updateImage();\n}\nfunction $f6c83a1fcfd19596$var$updateImage() {\n    $f6c83a1fcfd19596$var$imgEl.src = `https://raw.githubusercontent.com/google/model-viewer/master/packages/render-fidelity-tools/test/goldens/${$f6c83a1fcfd19596$var$params.model}/${$f6c83a1fcfd19596$var$params.imageType}-golden.png`;\n}\n\n\n//# sourceMappingURL=viewerTest.daf0f9c0.js.map\n","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\trgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tconst w = rgbe_header_info.width,\n\t\t\th = rgbe_header_info.height,\n\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\n\t\tlet data, type;\n\t\tlet numElements;\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = floatArray;\n\t\t\t\ttype = FloatType;\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = halfArray;\n\t\t\t\ttype = HalfFloatType;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn {\n\t\t\twidth: w, height: h,\n\t\t\tdata: data,\n\t\t\theader: rgbe_header_info.string,\n\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\texposure: rgbe_header_info.exposure,\n\t\t\ttype: type\n\t\t};\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst { textures, materials } = this;\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t};\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","import { PerspectiveCamera, Scene, Vector2, Clock, NormalBlending, NoBlending, AdditiveBlending } from 'three';\nimport { PathTracingSceneGenerator } from './PathTracingSceneGenerator.js';\nimport { PathTracingRenderer } from './PathTracingRenderer.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { GradientEquirectTexture } from '../textures/GradientEquirectTexture.js';\nimport { getIesTextures, getLights, getTextures } from './utils/sceneUpdateUtils.js';\nimport { ClampedInterpolationMaterial } from '../materials/fullscreen/ClampedInterpolationMaterial.js';\n\nfunction supportsFloatBlending( renderer ) {\n\n\treturn renderer.extensions.get( 'EXT_float_blend' );\n\n}\n\nconst _resolution = new Vector2();\nexport class WebGLPathTracer {\n\n\tget multipleImportanceSampling() {\n\n\t\treturn Boolean( this._pathTracer.material.defines.FEATURE_MIS );\n\n\t}\n\n\tset multipleImportanceSampling( v ) {\n\n\t\tthis._pathTracer.material.setDefine( 'FEATURE_MIS', v ? 1 : 0 );\n\n\t}\n\n\tget transmissiveBounces() {\n\n\t\treturn this._pathTracer.material.transmissiveBounces;\n\n\t}\n\n\tset transmissiveBounces( v ) {\n\n\t\tthis._pathTracer.material.transmissiveBounces = v;\n\n\t}\n\n\tget bounces() {\n\n\t\treturn this._pathTracer.material.bounces;\n\n\t}\n\n\tset bounces( v ) {\n\n\t\tthis._pathTracer.material.bounces = v;\n\n\t}\n\n\tget filterGlossyFactor() {\n\n\t\treturn this._pathTracer.material.filterGlossyFactor;\n\n\t}\n\n\tset filterGlossyFactor( v ) {\n\n\t\tthis._pathTracer.material.filterGlossyFactor = v;\n\n\t}\n\n\tget samples() {\n\n\t\treturn this._pathTracer.samples;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._pathTracer.target;\n\n\t}\n\n\tget tiles() {\n\n\t\treturn this._pathTracer.tiles;\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\t// members\n\t\tthis._renderer = renderer;\n\t\tthis._generator = new PathTracingSceneGenerator();\n\t\tthis._pathTracer = new PathTracingRenderer( renderer );\n\t\tthis._queueReset = false;\n\t\tthis._clock = new Clock();\n\n\t\tthis._lowResPathTracer = new PathTracingRenderer( renderer );\n\t\tthis._lowResPathTracer.tiles.set( 1, 1 );\n\t\tthis._quad = new FullScreenQuad( new ClampedInterpolationMaterial( {\n\t\t\tmap: null,\n\t\t\ttransparent: true,\n\t\t\tblending: NoBlending,\n\n\t\t\tpremultipliedAlpha: renderer.getContextAttributes().premultipliedAlpha,\n\t\t} ) );\n\t\tthis._materials = null;\n\n\t\t// options\n\t\tthis.renderDelay = 100;\n\t\tthis.minSamples = 5;\n\t\tthis.fadeDuration = 500;\n\t\tthis.enablePathTracing = true;\n\t\tthis.pausePathTracing = false;\n\t\tthis.dynamicLowRes = false;\n\t\tthis.lowResScale = 0.25;\n\t\tthis.renderScale = 1;\n\t\tthis.synchronizeRenderSize = true;\n\t\tthis.rasterizeScene = true;\n\t\tthis.renderToCanvas = true;\n\t\tthis.textureSize = new Vector2( 1024, 1024 );\n\t\tthis.rasterizeSceneCallback = ( scene, camera ) => {\n\n\t\t\tthis._renderer.render( scene, camera );\n\n\t\t};\n\n\t\tthis.renderToCanvasCallback = ( target, renderer, quad ) => {\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\t\t\tquad.render( renderer );\n\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t};\n\n\t\t// initialize the scene so it doesn't fail\n\t\tthis.setScene( new Scene(), new PerspectiveCamera() );\n\n\t}\n\n\tsetBVHWorker( worker ) {\n\n\t\tthis._generator.setBVHWorker( worker );\n\n\t}\n\n\tsetScene( scene, camera, options = {} ) {\n\n\t\tscene.updateMatrixWorld( true );\n\t\tcamera.updateMatrixWorld();\n\n\t\tconst generator = this._generator;\n\t\tgenerator.setObjects( scene );\n\n\t\tif ( this._buildAsync ) {\n\n\t\t\treturn generator.generateAsync( options.onProgress ).then( result => {\n\n\t\t\t\treturn this._updateFromResults( scene, camera, result );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconst result = generator.generate();\n\t\t\treturn this._updateFromResults( scene, camera, result );\n\n\t\t}\n\n\t}\n\n\tsetSceneAsync( ...args ) {\n\n\t\tthis._buildAsync = true;\n\t\tconst result = this.setScene( ...args );\n\t\tthis._buildAsync = false;\n\n\t\treturn result;\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tthis.camera = camera;\n\t\tthis.updateCamera();\n\n\t}\n\n\tupdateCamera() {\n\n\t\tconst camera = this.camera;\n\t\tcamera.updateMatrixWorld();\n\n\t\tthis._pathTracer.setCamera( camera );\n\t\tthis._lowResPathTracer.setCamera( camera );\n\t\tthis.reset();\n\n\t}\n\n\tupdateMaterials() {\n\n\t\tconst material = this._pathTracer.material;\n\t\tconst renderer = this._renderer;\n\t\tconst materials = this._materials;\n\t\tconst textureSize = this.textureSize;\n\n\t\t// TODO: reduce texture sources here - we don't want to do this in the\n\t\t// textures array because we need to pass the textures array into the\n\t\t// material target\n\t\tconst textures = getTextures( materials );\n\t\tmaterial.textures.setTextures( renderer, textures, textureSize.x, textureSize.y );\n\t\tmaterial.materials.updateFrom( materials, textures );\n\t\tthis.reset();\n\n\t}\n\n\tupdateLights() {\n\n\t\tconst scene = this.scene;\n\t\tconst renderer = this._renderer;\n\t\tconst material = this._pathTracer.material;\n\n\t\tconst lights = getLights( scene );\n\t\tconst iesTextures = getIesTextures( lights );\n\t\tmaterial.lights.updateFrom( lights, iesTextures );\n\t\tmaterial.iesProfiles.setTextures( renderer, iesTextures );\n\t\tthis.reset();\n\n\t}\n\n\tupdateEnvironment() {\n\n\t\tconst scene = this.scene;\n\t\tconst material = this._pathTracer.material;\n\n\t\t// update scene background\n\t\tmaterial.backgroundBlur = scene.backgroundBlurriness;\n\t\tmaterial.backgroundIntensity = scene.backgroundIntensity ?? 1;\n\t\tmaterial.backgroundRotation.makeRotationFromEuler( scene.backgroundRotation ).invert();\n\t\tif ( scene.background === null ) {\n\n\t\t\tmaterial.backgroundMap = null;\n\t\t\tmaterial.backgroundAlpha = 0;\n\n\t\t} else if ( scene.background.isColor ) {\n\n\t\t\tthis._colorBackground = this._colorBackground || new GradientEquirectTexture( 16 );\n\n\t\t\tconst colorBackground = this._colorBackground;\n\t\t\tif ( ! colorBackground.topColor.equals( scene.background ) ) {\n\n\t\t\t\t// set the texture color\n\t\t\t\tcolorBackground.topColor.set( scene.background );\n\t\t\t\tcolorBackground.bottomColor.set( scene.background );\n\t\t\t\tcolorBackground.update();\n\n\t\t\t}\n\n\t\t\t// assign to material\n\t\t\tmaterial.backgroundMap = colorBackground;\n\t\t\tmaterial.backgroundAlpha = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.backgroundMap = scene.background;\n\t\t\tmaterial.backgroundAlpha = 1;\n\n\t\t}\n\n\t\t// update scene environment\n\t\tmaterial.environmentIntensity = scene.environmentIntensity ?? 1;\n\t\tmaterial.environmentRotation.makeRotationFromEuler( scene.environmentRotation ).invert();\n\t\tif ( this._previousEnvironment !== scene.environment ) {\n\n\t\t\tif ( scene.environment ) {\n\n\t\t\t\t// TODO: Consider setting this to the highest supported bit depth by checking for\n\t\t\t\t// OES_texture_float_linear or OES_texture_half_float_linear. Requires changes to\n\t\t\t\t// the equirect uniform\n\t\t\t\tmaterial.envMapInfo.updateFrom( scene.environment );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.environmentIntensity = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._previousEnvironment = scene.environment;\n\t\tthis.reset();\n\n\t}\n\n\t_updateFromResults( scene, camera, results ) {\n\n\t\tconst {\n\t\t\tmaterials,\n\t\t\tgeometry,\n\t\t\tbvh,\n\t\t\tbvhChanged,\n\t\t} = results;\n\n\t\tthis._materials = materials;\n\n\t\tconst pathTracer = this._pathTracer;\n\t\tconst material = pathTracer.material;\n\n\t\tif ( bvhChanged ) {\n\n\t\t\tmaterial.bvh.updateFrom( bvh );\n\t\t\tmaterial.attributesArray.updateFrom(\n\t\t\t\tgeometry.attributes.normal,\n\t\t\t\tgeometry.attributes.tangent,\n\t\t\t\tgeometry.attributes.uv,\n\t\t\t\tgeometry.attributes.color,\n\t\t\t);\n\n\t\t\tmaterial.materialIndexAttribute.updateFrom( geometry.attributes.materialIndex );\n\n\t\t}\n\n\t\t// save previously used items\n\t\tthis._previousScene = scene;\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.updateCamera();\n\t\tthis.updateMaterials();\n\t\tthis.updateEnvironment();\n\t\tthis.updateLights();\n\n\t\treturn results;\n\n\t}\n\n\trenderSample() {\n\n\t\tconst lowResPathTracer = this._lowResPathTracer;\n\t\tconst pathTracer = this._pathTracer;\n\t\tconst renderer = this._renderer;\n\t\tconst clock = this._clock;\n\t\tconst quad = this._quad;\n\n\t\tthis._updateScale();\n\n\t\tif ( this._queueReset ) {\n\n\t\t\tpathTracer.reset();\n\t\t\tlowResPathTracer.reset();\n\t\t\tthis._queueReset = false;\n\n\t\t\tquad.material.opacity = 0;\n\t\t\tclock.start();\n\n\t\t}\n\n\t\t// render the path tracing sample after enough time has passed\n\t\tconst delta = clock.getDelta() * 1e3;\n\t\tconst elapsedTime = clock.getElapsedTime() * 1e3;\n\t\tif ( ! this.pausePathTracing && this.enablePathTracing && this.renderDelay <= elapsedTime ) {\n\n\t\t\tpathTracer.update();\n\n\t\t}\n\n\t\t// when alpha is enabled we use a manual blending system rather than\n\t\t// rendering with a blend function\n\t\tpathTracer.alpha = pathTracer.material.backgroundAlpha !== 1 || ! supportsFloatBlending( renderer );\n\t\tlowResPathTracer.alpha = pathTracer.alpha;\n\n\t\tif ( this.renderToCanvas ) {\n\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst minSamples = this.minSamples;\n\n\t\t\tif ( elapsedTime >= this.renderDelay && this.samples >= this.minSamples ) {\n\n\t\t\t\tif ( this.fadeDuration !== 0 ) {\n\n\t\t\t\t\tquad.material.opacity = Math.min( quad.material.opacity + delta / this.fadeDuration, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tquad.material.opacity = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render the fallback if we haven't rendered enough samples, are paused, or are occluded\n\t\t\tif ( ! this.enablePathTracing || this.samples < minSamples || quad.material.opacity < 1 ) {\n\n\t\t\t\tif ( this.dynamicLowRes ) {\n\n\t\t\t\t\tif ( lowResPathTracer.samples < 1 ) {\n\n\t\t\t\t\t\tlowResPathTracer.material = pathTracer.material;\n\t\t\t\t\t\tlowResPathTracer.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst currentOpacity = quad.material.opacity;\n\t\t\t\t\tquad.material.opacity = 1 - quad.material.opacity;\n\t\t\t\t\tquad.material.map = lowResPathTracer.target.texture;\n\t\t\t\t\tquad.render( renderer );\n\t\t\t\t\tquad.material.opacity = currentOpacity;\n\n\t\t\t\t} else if ( this.rasterizeScene ) {\n\n\t\t\t\t\tthis.rasterizeSceneCallback( this.scene, this.camera );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( this.enablePathTracing && quad.material.opacity > 0 ) {\n\n\t\t\t\tif ( quad.material.opacity < 1 ) {\n\n\t\t\t\t\t// use additive blending when the low res texture is rendered so we can fade the\n\t\t\t\t\t// background out while the full res fades in\n\t\t\t\t\tquad.material.blending = this.dynamicLowRes ? AdditiveBlending : NormalBlending;\n\n\t\t\t\t}\n\n\t\t\t\tquad.material.map = pathTracer.target.texture;\n\t\t\t\tthis.renderToCanvasCallback( pathTracer.target, renderer, quad );\n\t\t\t\tquad.material.blending = NoBlending;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis._queueReset = true;\n\t\tthis._pathTracer.samples = 0;\n\n\t}\n\n\tdispose() {\n\n\t\tthis._renderQuad.dispose();\n\t\tthis._renderQuad.material.dispose();\n\t\tthis._pathTracer.dispose();\n\n\t}\n\n\t_updateScale() {\n\n\t\t// update the path tracer scale if it has changed\n\t\tif ( this.synchronizeRenderSize ) {\n\n\t\t\tthis._renderer.getDrawingBufferSize( _resolution );\n\n\t\t\tconst w = Math.floor( this.renderScale * _resolution.x );\n\t\t\tconst h = Math.floor( this.renderScale * _resolution.y );\n\n\t\t\tthis._pathTracer.getSize( _resolution );\n\t\t\tif ( _resolution.x !== w || _resolution.y !== h ) {\n\n\t\t\t\tconst lowResScale = this.lowResScale;\n\t\t\t\tthis._pathTracer.setSize( w, h );\n\t\t\t\tthis._lowResPathTracer.setSize( Math.floor( w * lowResScale ), Math.floor( h * lowResScale ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { Color, Vector3 } from 'three';\nimport { ProceduralEquirectTexture } from './ProceduralEquirectTexture.js';\n\nconst _direction = new Vector3();\nexport class GradientEquirectTexture extends ProceduralEquirectTexture {\n\n\tconstructor( resolution = 512 ) {\n\n\t\tsuper( resolution, resolution );\n\n\t\tthis.topColor = new Color().set( 0xffffff );\n\t\tthis.bottomColor = new Color().set( 0x000000 );\n\t\tthis.exponent = 2;\n\t\tthis.generationCallback = ( polar, uv, coord, color ) => {\n\n\t\t\t_direction.setFromSpherical( polar );\n\n\t\t\tconst t = _direction.y * 0.5 + 0.5;\n\t\t\tcolor.lerpColors( this.bottomColor, this.topColor, t ** this.exponent );\n\n\t\t};\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\n\t\tthis.topColor.copy( other.topColor );\n\t\tthis.bottomColor.copy( other.bottomColor );\n\t\treturn this;\n\n\t}\n\n}\n","import {\n\tClampToEdgeWrapping,\n\tColor,\n\tDataTexture,\n\tEquirectangularReflectionMapping,\n\tLinearFilter,\n\tRepeatWrapping,\n\tRGBAFormat,\n\tSpherical,\n\tVector2,\n\tFloatType\n} from 'three';\n\nconst _uv = new Vector2();\nconst _coord = new Vector2();\nconst _polar = new Spherical();\nconst _color = new Color();\nexport class ProceduralEquirectTexture extends DataTexture {\n\n\tconstructor( width = 512, height = 512 ) {\n\n\t\tsuper(\n\t\t\tnew Float32Array( width * height * 4 ),\n\t\t\twidth, height, RGBAFormat, FloatType, EquirectangularReflectionMapping,\n\t\t\tRepeatWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter,\n\t\t);\n\n\t\tthis.generationCallback = null;\n\n\t}\n\n\tupdate() {\n\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t\tconst { data, width, height } = this.image;\n\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\t_coord.set( width, height );\n\n\t\t\t\t_uv.set( x / width, y / height );\n\t\t\t\t_uv.x -= 0.5;\n\t\t\t\t_uv.y = 1.0 - _uv.y;\n\n\t\t\t\t_polar.theta = _uv.x * 2.0 * Math.PI;\n\t\t\t\t_polar.phi = _uv.y * Math.PI;\n\t\t\t\t_polar.radius = 1.0;\n\n\t\t\t\tthis.generationCallback( _polar, _uv, _coord, _color );\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst i4 = 4 * i;\n\t\t\t\tdata[ i4 + 0 ] = ( _color.r );\n\t\t\t\tdata[ i4 + 1 ] = ( _color.g );\n\t\t\t\tdata[ i4 + 2 ] = ( _color.b );\n\t\t\t\tdata[ i4 + 3 ] = ( 1.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\t\tthis.generationCallback = other.generationCallback;\n\t\treturn this;\n\n\t}\n\n}\n","import { ShaderMaterial } from 'three';\n\n// Material that tone maps a texture before performing interpolation to prevent\n// unexpected high values during texture stretching interpolation.\n// Emulates browser image stretching\nexport class ClampedInterpolationMaterial extends ShaderMaterial {\n\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tif ( this.uniforms ) {\n\n\t\t\tthis.uniforms.opacity.value = v;\n\n\t\t}\n\n\t}\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float opacity;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec4 clampedTexelFatch( sampler2D map, ivec2 px, int lod ) {\n\n\t\t\t\t\tvec4 res = texelFetch( map, ivec2( px.x, px.y ), 0 );\n\n\t\t\t\t\t#if defined( TONE_MAPPING )\n\n\t\t\t\t\tres.xyz = toneMapping( res.xyz );\n\n\t\t\t\t\t#endif\n\n\t\t\t  \t\treturn linearToOutputTexel( res );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec2 size = vec2( textureSize( map, 0 ) );\n\t\t\t\t\tvec2 pxUv = vUv * size;\n\t\t\t\t\tvec2 pxCurr = floor( pxUv );\n\t\t\t\t\tvec2 pxFrac = fract( pxUv ) - 0.5;\n\t\t\t\t\tvec2 pxOffset;\n\t\t\t\t\tpxOffset.x = pxFrac.x > 0.0 ? 1.0 : - 1.0;\n\t\t\t\t\tpxOffset.y = pxFrac.y > 0.0 ? 1.0 : - 1.0;\n\n\t\t\t\t\tvec2 pxNext = clamp( pxOffset + pxCurr, vec2( 0.0 ), size - 1.0 );\n\t\t\t\t\tvec2 alpha = abs( pxFrac );\n\n\t\t\t\t\tvec4 p1 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tvec4 p2 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxNext.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxNext.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tgl_FragColor = mix( p1, p2, alpha.y );\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { Box3, BufferAttribute } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport { WorkerBase } from './utils/WorkerBase.js';\nimport { convertToBufferType, isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { GenerateMeshBVHWorker } from './GenerateMeshBVHWorker.js';\nimport { ensureIndex } from '../core/build/geometryUtils.js';\n\nconst DEFAULT_WORKER_COUNT = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : 4;\nclass _ParallelMeshBVHWorker extends WorkerBase {\n\n\tconstructor() {\n\n\t\tconst worker = new Worker( new URL( './parallelMeshBVH.worker.js', import.meta.url ), { type: 'module' } );\n\t\tsuper( worker );\n\n\t\tthis.name = 'ParallelMeshBVHWorker';\n\t\tthis.maxWorkerCount = Math.max( DEFAULT_WORKER_COUNT, 4 );\n\n\t\tif ( ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'ParallelMeshBVHWorker: Shared Array Buffers are not supported.' );\n\n\t\t}\n\n\t}\n\n\trunTask( worker, geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tif ( ! geometry.index && ! options.indirect ) {\n\n\t\t\t\tensureIndex( geometry, options );\n\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tgeometry.getAttribute( 'position' ).isInterleavedBufferAttribute ||\n\t\t\t\tgeometry.index && geometry.index.isInterleavedBufferAttribute\n\t\t\t) {\n\n\t\t\t\tthrow new Error( 'ParallelMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.' );\n\n\t\t\t}\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `ParallelMeshBVHWorker: ${ e.message }` ) );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.serialized ) {\n\n\t\t\t\t\tconst { serialized, position } = data;\n\t\t\t\t\tconst bvh = MeshBVH.deserialize( serialized, geometry, { setIndex: false } );\n\t\t\t\t\tconst boundsOptions = {\n\t\t\t\t\t\tsetBoundingBox: true,\n\t\t\t\t\t\t...options,\n\t\t\t\t\t};\n\n\t\t\t\t\t// we need to replace the arrays because they're neutered entirely by the\n\t\t\t\t\t// webworker transfer.\n\t\t\t\t\tgeometry.attributes.position.array = position;\n\t\t\t\t\tif ( serialized.index ) {\n\n\t\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\t\tgeometry.index.array = serialized.index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst newIndex = new BufferAttribute( serialized.index, 1, false );\n\t\t\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundsOptions.setBoundingBox ) {\n\n\t\t\t\t\t\tgeometry.boundingBox = bvh.getBoundingBox( new Box3() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( bvh );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\t\tconst position = geometry.attributes.position.array;\n\t\t\tworker.postMessage( {\n\n\t\t\t\toperation: 'BUILD_BVH',\n\t\t\t\tmaxWorkerCount: this.maxWorkerCount,\n\t\t\t\tindex: convertToBufferType( index, SharedArrayBuffer ),\n\t\t\t\tposition: convertToBufferType( position, SharedArrayBuffer ),\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t\tgroups: [ ... geometry.groups ],\n\t\t\t\t},\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\nexport class ParallelMeshBVHWorker {\n\n\tconstructor() {\n\n\t\tif ( isSharedArrayBufferSupported() ) {\n\n\t\t\treturn new _ParallelMeshBVHWorker();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'ParallelMeshBVHWorker: SharedArrayBuffers not supported. Falling back to single-threaded GenerateMeshBVHWorker.' );\n\n\t\t\tconst object = new GenerateMeshBVHWorker();\n\t\t\tobject.maxWorkerCount = DEFAULT_WORKER_COUNT;\n\t\t\treturn object;\n\n\t\t}\n\n\t}\n\n}\n","export class WorkerBase {\n\n\tconstructor( worker ) {\n\n\t\tthis.name = 'WorkerBase';\n\t\tthis.running = false;\n\t\tthis.worker = worker;\n\t\tthis.worker.onerror = e => {\n\n\t\t\tif ( e.message ) {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker with error \"${ e.message }\"` );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker.` );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\trunTask() {}\n\n\tgenerate( ...args ) {\n\n\t\tif ( this.running ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Already running job.' );\n\n\t\t}\n\n\t\tif ( this.worker === null ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Worker has been disposed.' );\n\n\t\t}\n\n\t\tthis.running = true;\n\n\t\tconst promise = this.runTask( this.worker, ...args );\n\t\tpromise.finally( () => {\n\n\t\t\tthis.running = false;\n\n\t\t} );\n\n\t\treturn promise;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.worker.terminate();\n\t\tthis.worker = null;\n\n\t}\n\n}\n","import { Box3, BufferAttribute } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport { WorkerBase } from './utils/WorkerBase.js';\n\nexport class GenerateMeshBVHWorker extends WorkerBase {\n\n\tconstructor() {\n\n\t\tconst worker = new Worker( new URL( './generateMeshBVH.worker.js', import.meta.url ), { type: 'module' } );\n\t\tsuper( worker );\n\t\tthis.name = 'GenerateMeshBVHWorker';\n\n\t}\n\n\trunTask( worker, geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tif (\n\t\t\t\tgeometry.getAttribute( 'position' ).isInterleavedBufferAttribute ||\n\t\t\t\tgeometry.index && geometry.index.isInterleavedBufferAttribute\n\t\t\t) {\n\n\t\t\t\tthrow new Error( 'GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.' );\n\n\t\t\t}\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `GenerateMeshBVHWorker: ${ e.message }` ) );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.serialized ) {\n\n\t\t\t\t\tconst { serialized, position } = data;\n\t\t\t\t\tconst bvh = MeshBVH.deserialize( serialized, geometry, { setIndex: false } );\n\t\t\t\t\tconst boundsOptions = Object.assign( {\n\n\t\t\t\t\t\tsetBoundingBox: true,\n\n\t\t\t\t\t}, options );\n\n\t\t\t\t\t// we need to replace the arrays because they're neutered entirely by the\n\t\t\t\t\t// webworker transfer.\n\t\t\t\t\tgeometry.attributes.position.array = position;\n\t\t\t\t\tif ( serialized.index ) {\n\n\t\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\t\tgeometry.index.array = serialized.index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst newIndex = new BufferAttribute( serialized.index, 1, false );\n\t\t\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundsOptions.setBoundingBox ) {\n\n\t\t\t\t\t\tgeometry.boundingBox = bvh.getBoundingBox( new Box3() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( bvh );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\t\tconst position = geometry.attributes.position.array;\n\t\t\tconst transferable = [ position ];\n\t\t\tif ( index ) {\n\n\t\t\t\ttransferable.push( index );\n\n\t\t\t}\n\n\t\t\tworker.postMessage( {\n\n\t\t\t\tindex,\n\t\t\t\tposition,\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t\tgroups: [ ... geometry.groups ],\n\t\t\t\t},\n\n\t\t\t}, transferable.map( arr => arr.buffer ).filter( v => ( typeof SharedArrayBuffer === 'undefined' ) || ! ( v instanceof SharedArrayBuffer ) ) );\n\n\t\t} );\n\n\t}\n\n}\n","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(\"generateMeshBVH.worker.373f3c58.js\");\nmodule.exports = workerURL(url.toString(), url.origin, true);","\"use strict\";\n\nmodule.exports = function (workerUrl, origin, isESM) {\n  if (origin === self.location.origin) {\n    // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n  } else {\n    // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n    var source = isESM ? 'import ' + JSON.stringify(workerUrl) + ';' : 'importScripts(' + JSON.stringify(workerUrl) + ');';\n    return URL.createObjectURL(new Blob([source], {\n      type: 'application/javascript'\n    }));\n  }\n};","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(\"parallelMeshBVH.worker.22cf4bb0.js\");\nmodule.exports = workerURL(url.toString(), url.origin, true);","let _styleElement;\nfunction initializeStyles() {\n\n\tif ( _styleElement ) {\n\n\t\treturn;\n\n\t}\n\n\t_styleElement = document.createElement( 'style' );\n\t_styleElement.textContent = /* css */`\n\n\t\t.loader-container, .description {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\tfont-family: 'Courier New', Courier, monospace;\n\t\t\tcolor: white;\n\t\t\tfont-weight: light;\n\t\t\talign-items: flex-start;\n\t\t\tfont-size: 14px;\n\t\t\tpointer-events: none;\n\t\t\tuser-select: none;\n\t\t}\n\n\t\t.loader-container {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t.description {\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t\tpadding: 5px 0;\n\t\t}\n\n\t\t.loader-container .bar {\n\t\t\theight: 2px;\n\t\t\tbackground: white;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.loader-container .credits,\n\t\t.loader-container .samples,\n\t\t.loader-container .percentage {\n\t\t\tpadding: 5px;\n\t\t\tmargin: 0 0 1px 1px;\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\n\t\t\tborder-radius: 2px;\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t.loader-container:not(.loading) .bar,\n\t\t.loader-container:not(.loading) .percentage,\n\t\t.loader-container.loading .credits,\n\t\t.loader-container.loading .samples,\n\t\t.loader-container .credits:empty {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t.loader-container .credits a,\n\t\t.loader-container .credits,\n\t\t.loader-container .samples {\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\n\t\t}\n\t`;\n\tdocument.head.appendChild( _styleElement );\n\n}\n\nexport class LoaderElement {\n\n\tconstructor() {\n\n\t\tinitializeStyles();\n\n\t\tconst container = document.createElement( 'div' );\n\t\tcontainer.classList.add( 'loader-container' );\n\n\t\tconst percentageEl = document.createElement( 'div' );\n\t\tpercentageEl.classList.add( 'percentage' );\n\t\tcontainer.appendChild( percentageEl );\n\n\t\tconst samplesEl = document.createElement( 'div' );\n\t\tsamplesEl.classList.add( 'samples' );\n\t\tcontainer.appendChild( samplesEl );\n\n\t\tconst creditsEl = document.createElement( 'div' );\n\t\tcreditsEl.classList.add( 'credits' );\n\t\tcontainer.appendChild( creditsEl );\n\n\t\tconst loaderBarEl = document.createElement( 'div' );\n\t\tloaderBarEl.classList.add( 'bar' );\n\t\tcontainer.appendChild( loaderBarEl );\n\n\t\tconst descriptionEl = document.createElement( 'div' );\n\t\tdescriptionEl.classList.add( 'description' );\n\t\tcontainer.appendChild( descriptionEl );\n\n\t\tthis._description = descriptionEl;\n\t\tthis._loaderBar = loaderBarEl;\n\t\tthis._percentage = percentageEl;\n\t\tthis._credits = creditsEl;\n\t\tthis._samples = samplesEl;\n\t\tthis._container = container;\n\n\t\tthis.setPercentage( 0 );\n\n\t}\n\n\tattach( container ) {\n\n\t\tcontainer.appendChild( this._container );\n\t\tcontainer.appendChild( this._description );\n\n\t}\n\n\tsetPercentage( perc ) {\n\n\t\tthis._loaderBar.style.width = `${ perc * 100 }%`;\n\n\t\tif ( perc === 0 ) {\n\n\t\t\tthis._percentage.innerText = 'Loading...';\n\n\t\t} else {\n\n\t\t\tthis._percentage.innerText = `${ ( perc * 100 ).toFixed( 0 ) }%`;\n\n\t\t}\n\n\t\tif ( perc >= 1 ) {\n\n\t\t\tthis._container.classList.remove( 'loading' );\n\n\t\t} else {\n\n\t\t\tthis._container.classList.add( 'loading' );\n\n\t\t}\n\n\t}\n\n\tsetSamples( count ) {\n\n\t\tthis._samples.innerText = `${ Math.floor( count ) } samples`;\n\n\t}\n\n\tsetCredits( credits ) {\n\n\t\tthis._credits.innerHTML = credits;\n\n\t}\n\n\tsetDescription( description ) {\n\n\t\tthis._description.innerHTML = description;\n\n\t}\n\n}\n","import { ShaderMaterial } from 'three';\n\nexport class MaterialBase extends ShaderMaterial {\n\n\tconstructor( shader ) {\n\n\t\tsuper( shader );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n","export const math_functions = /* glsl */`\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n","export const util_functions = /* glsl */`\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n","export const ggx_functions = /* glsl */`\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n","require('./helpers/bundle-manifest').register(new __parcel__URL__(\"\").toString(),JSON.parse(\"[\\\"bTBll\\\",\\\"viewerTest.daf0f9c0.js\\\",\\\"512E4\\\",\\\"parallelMeshBVH.worker.22cf4bb0.js\\\",\\\"9P1cE\\\",\\\"generateMeshBVH.worker.cd4b9fc6.js\\\",\\\"lWWke\\\",\\\"generateMeshBVH.worker.373f3c58.js\\\",\\\"9P1cE\\\",\\\"generateMeshBVH.worker.cd4b9fc6.js\\\",\\\"jwbL2\\\",\\\"aoRender.e5303912.js\\\",\\\"63CMm\\\",\\\"aoRender.a1271ff5.js\\\",\\\"2tzBs\\\",\\\"aoRender.89c1b67b.js\\\",\\\"6UuCC\\\",\\\"aoRender.5fc59dbe.js\\\",\\\"6mMEU\\\",\\\"aoRender.fc8349f1.js\\\",\\\"i0zVc\\\",\\\"aoRender.dcf40b33.js\\\",\\\"j19h5\\\",\\\"aoRender.e8b1599c.js\\\",\\\"eif6c\\\",\\\"areaLight.5654e8b2.js\\\"]\"));","import {\n\tACESFilmicToneMapping,\n\tNoToneMapping,\n\tLoadingManager,\n\tWebGLRenderer,\n\tScene,\n\tPerspectiveCamera,\n\tEquirectangularReflectionMapping,\n\tMathUtils,\n\tGroup,\n\tSphere,\n\tBox3,\n} from 'three';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { MaterialReducer, WebGLPathTracer } from '../src/index.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { ParallelMeshBVHWorker } from 'three-mesh-bvh/src/workers/ParallelMeshBVHWorker.js';\nimport { LoaderElement } from './utils/LoaderElement.js';\n\nconst CONFIG_URL = 'https://raw.githubusercontent.com/google/model-viewer/master/packages/render-fidelity-tools/test/config.json';\nconst BASE_URL = 'https://raw.githubusercontent.com/google/model-viewer/master/packages/render-fidelity-tools/test/config/';\n\nconst urlParams = new URLSearchParams( window.location.search );\nconst maxSamples = parseInt( urlParams.get( 'samples' ) ) || - 1;\nconst hideUI = urlParams.get( 'hideUI' ) === 'true';\nconst tiles = parseInt( urlParams.get( 'tiles' ) ) || 2;\nconst scale = parseInt( urlParams.get( 'scale' ) ) || 1 / window.devicePixelRatio;\n\nconst params = {\n\n\tenable: true,\n\tbounces: 10,\n\ttransmissiveBounces: 10,\n\tpause: false,\n\tmultipleImportanceSampling: true,\n\tacesToneMapping: true,\n\ttiles: tiles,\n\tscale: scale,\n\n\tmodel: '',\n\tcheckerboardTransparency: true,\n\tdisplayImage: false,\n\timageMode: 'overlay',\n\timageOpacity: 1.0,\n\timageType: 'dspbr-pt',\n\n};\n\nlet containerEl, imgEl, loader;\nlet gui, model, envMap;\nlet pathTracer, renderer, camera, scene, controls;\nlet loadingModel = false;\nlet delaySamples = 0;\nlet modelDatabase;\n\ninit();\n\nasync function init() {\n\n\t// get elements\n\tcontainerEl = document.getElementById( 'container' );\n\timgEl = document.querySelector( 'img' );\n\n\tif ( hideUI ) {\n\n\t\tcontainerEl.style.background = 'transparent';\n\t\tdocument.body.style.background = 'transparent';\n\n\t}\n\n\tloader = new LoaderElement();\n\tif ( ! hideUI ) {\n\n\t\tloader.attach( document.body );\n\n\t}\n\n\t// renderer\n\trenderer = new WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );\n\trenderer.physicallyCorrectLights = true;\n\trenderer.toneMapping = ACESFilmicToneMapping;\n\trenderer.setClearAlpha( 0 );\n\tcontainerEl.appendChild( renderer.domElement );\n\n\t// path tracer\n\tpathTracer = new WebGLPathTracer( renderer );\n\tpathTracer.filterGlossyFactor = 0.5;\n\tpathTracer.tiles.set( params.tiles );\n\tpathTracer.setBVHWorker( new ParallelMeshBVHWorker() );\n\tpathTracer.multipleImportanceSampling = params.multipleImportanceSampling;\n\n\t// scene\n\tscene = new Scene();\n\n\t// init camera\n\tconst aspect = window.innerWidth / window.innerHeight;\n\tcamera = new PerspectiveCamera( 60, aspect, 0.01, 500 );\n\tcamera.position.set( - 1, 0.25, 1 );\n\n\t// controls\n\tcontrols = new OrbitControls( camera, containerEl );\n\tcontrols.addEventListener( 'change', () => pathTracer.updateCamera() );\n\n\t// models\n\tconst { scenarios } = await fetch( CONFIG_URL ).then( res => res.json() );\n\tmodelDatabase = {};\n\tscenarios.forEach( s => modelDatabase[ s.name ] = s );\n\n\twindow.addEventListener( 'hashchange', onHashChange );\n\tonHashChange();\n\n\tanimate();\n\n}\n\nfunction animate() {\n\n\trequestAnimationFrame( animate );\n\n\t// if rendering has completed then don't render\n\tif ( pathTracer.samples >= maxSamples && maxSamples !== - 1 ) {\n\n\t\treturn;\n\n\t}\n\n\timgEl.style.display = ! params.displayImage ? 'none' : 'inline-block';\n\timgEl.style.opacity = params.imageMode === 'side-by-side' ? 1.0 : params.imageOpacity;\n\timgEl.style.position = params.imageMode === 'side-by-side' ? 'initial' : 'absolute';\n\timgEl.style.width = renderer.domElement.style.width;\n\timgEl.style.height = renderer.domElement.style.height;\n\n\tif ( loadingModel ) {\n\n\t\treturn;\n\n\t}\n\n\t// TODO: use a delay field from WebGLPathTracer\n\tif ( params.enable && delaySamples === 0 ) {\n\n\t\tpathTracer.enablePathTracing = params.enable;\n\t\tpathTracer.pausePathTracing = params.pause || pathTracer.samples > maxSamples && maxSamples !== - 1;\n\n\t\tpathTracer.renderSample();\n\n\t} else if ( delaySamples > 0 || ! params.enable ) {\n\n\t\tdelaySamples = Math.max( delaySamples - 1, 0 );\n\t\trenderer.render( scene, camera );\n\n\t}\n\n\t// rendering has completed\n\tif ( pathTracer.samples >= maxSamples && maxSamples !== - 1 ) {\n\n\t\trequestAnimationFrame( () => window.dispatchEvent( new Event( 'render-complete' ) ) );\n\n\t}\n\n\tloader.setSamples( pathTracer.samples );\n\n}\n\nfunction onHashChange() {\n\n\tparams.model = Object.keys( modelDatabase )[ 0 ];\n\tif ( window.location.hash ) {\n\n\t\tconst modelName = window.location.hash.substring( 1 ).replaceAll( '%20', ' ' );\n\t\tif ( modelName in modelDatabase ) {\n\n\t\t\tparams.model = modelName;\n\n\t\t}\n\n\t}\n\n\tupdateModel();\n\n}\n\nfunction onParamsChange() {\n\n\tif ( pathTracer.tiles !== 1.0 ) {\n\n\t\tdelaySamples = 1;\n\n\t}\n\n\tif ( params.checkerboardTransparency ) {\n\n\t\tcontainerEl.classList.add( 'checkerboard' );\n\n\t} else {\n\n\t\tcontainerEl.classList.remove( 'checkerboard' );\n\n\t}\n\n\tpathTracer.multipleImportanceSampling = params.multipleImportanceSampling;\n\tpathTracer.bounces = params.bounces;\n\tpathTracer.transmissiveBounces = params.transmissiveBounces;\n\tpathTracer.renderScale = params.scale;\n\n\tconst model = modelDatabase[ params.model ];\n\tscene.background = model && model.renderSkybox ? scene.environment : null;\n\tpathTracer.updateEnvironment();\n\n}\n\nfunction buildGui() {\n\n\tif ( hideUI ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tgui = new GUI();\n\tgui.add( params, 'model', Object.keys( modelDatabase ) ).onChange( v => {\n\n\t\twindow.location.hash = v;\n\n\t} );\n\n\tconst pathTracingFolder = gui.addFolder( 'Path Tracer' );\n\tpathTracingFolder.add( params, 'enable' );\n\tpathTracingFolder.add( params, 'pause' );\n\tpathTracingFolder.add( params, 'scale', 0.1, 1 ).onChange( onParamsChange );\n\tpathTracingFolder.add( params, 'multipleImportanceSampling' ).onChange( onParamsChange );\n\tpathTracingFolder.add( params, 'acesToneMapping' ).onChange( v => {\n\n\t\trenderer.toneMapping = v ? ACESFilmicToneMapping : NoToneMapping;\n\n\t} );\n\tpathTracingFolder.add( params, 'tiles', 1, 10, 1 ).onChange( v => {\n\n\t\tpathTracer.tiles.set( v, v );\n\n\t} );\n\tpathTracingFolder.add( params, 'bounces', 1, 20, 1 ).onChange( onParamsChange );\n\tpathTracingFolder.add( params, 'transmissiveBounces', 1, 20, 1 ).onChange( onParamsChange );\n\n\tconst comparisonFolder = gui.addFolder( 'Comparison' );\n\tcomparisonFolder.add( params, 'displayImage' );\n\tcomparisonFolder.add( params, 'imageMode', [ 'overlay', 'side-by-side' ] );\n\tcomparisonFolder.add( params, 'imageType', [\n\t\t'dspbr-pt',\n\t\t'filament',\n\t\t'babylon',\n\t\t'gltf-sample-viewer',\n\t\t'model-viewer',\n\t\t'rhodonite',\n\t\t'stellar'\n\t] ).onChange( updateImage );\n\tcomparisonFolder.add( params, 'imageOpacity', 0, 1.0 );\n\tcomparisonFolder.add( params, 'checkerboardTransparency' ).onChange( onParamsChange );\n\n}\n\nasync function updateModel() {\n\n\t// dispose of a gui\n\tif ( gui ) {\n\n\t\tcontainerEl.classList.remove( 'checkerboard' );\n\t\tgui.destroy();\n\t\tgui = null;\n\n\t}\n\n\t// dispose of everything\n\tif ( model ) {\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tif ( material[ key ] && material[ key ].isTexture ) {\n\n\t\t\t\t\t\tmaterial[ key ].dispose();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tscene.remove( model );\n\n\t}\n\n\t// dispose of the background\n\tif ( envMap ) {\n\n\t\tenvMap.dispose();\n\n\t}\n\n\tconst modelInfo = modelDatabase[ params.model ];\n\tconst {\n\t\tverticalFoV = 45,\n\t\tlighting = '../../../shared-assets/environments/lightroom_14b.hdr',\n\t} = modelInfo;\n\n\tlet {\n\t\torbit = {},\n\t\ttarget = {},\n\t\tdimensions = {},\n\t} = modelInfo;\n\n\torbit = { theta: 0, phi: 90, radius: 1, ...orbit };\n\ttarget = { x: 0, y: 0, z: 0, ...target };\n\tdimensions = { width: 768, height: 768, ...dimensions };\n\n\t// add a minimal radius so the camera orientation is correct when radius is 0\n\torbit.radius = Math.max( orbit.radius, 1e-5 );\n\n\tloadingModel = true;\n\tcontainerEl.style.display = 'none';\n\n\t// load assets\n\tconst envUrl = new URL( lighting, BASE_URL ).toString();\n\tconst modelUrl = new URL( modelInfo.model, BASE_URL )\n\t\t.toString()\n\t\t.replace( /.*?glTF-Sample-Assets/, 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main' );\n\n\tconst manager = new LoadingManager();\n\tconst [ envTexture, gltf ] = await Promise.all( [\n\t\tnew RGBELoader( manager ).loadAsync( envUrl ),\n\t\tnew GLTFLoader( manager ).setMeshoptDecoder( MeshoptDecoder )\n\t\t\t.loadAsync( modelUrl, progress => {\n\n\t\t\t\tif ( progress.total !== 0 && progress.total >= progress.loaded ) {\n\n\t\t\t\t\tloader.setPercentage( 0.5 * progress.loaded / progress.total );\n\n\t\t\t\t}\n\n\t\t\t} ),\n\t\tnew Promise( resolve => manager.onLoad = resolve ),\n\t] );\n\n\tenvMap = envTexture;\n\tenvMap.mapping = EquirectangularReflectionMapping;\n\tscene.environment = envMap;\n\n\tmodel = gltf.scene;\n\n\t// reduce the used materials\n\tconst reducer = new MaterialReducer();\n\treducer.process( model );\n\n\tconst targetsToDisconnect = [];\n\tmodel.traverse( c => {\n\n\t\tif ( c.isLight && c.target ) {\n\n\t\t\ttargetsToDisconnect.push( c.target );\n\n\t\t}\n\n\t} );\n\n\t// disconnect all light targets from parents because that's what happens after a clone which\n\t// is needed to match the model viewer setup\n\ttargetsToDisconnect.forEach( t => t.removeFromParent() );\n\n\t// add a parent group to process the parent offset\n\tconst targetGroup = new Group();\n\ttargetGroup.position.set( - target.x, - target.y, - target.z );\n\ttargetGroup.add( model );\n\n\t// replace the target group TODO\n\tmodel = targetGroup;\n\tmodel.updateMatrixWorld( true );\n\tscene.add( model );\n\n\tconst box = new Box3();\n\tconst sphere = new Sphere();\n\tbox.setFromObject( model );\n\tbox.getBoundingSphere( sphere );\n\n\t// mirror the model-viewer near / far planes\n\tconst radius = Math.max( orbit.radius, sphere.radius );\n\tcamera.near = 2 * radius / 1000;\n\tcamera.far = 2 * radius;\n\tcamera.updateProjectionMatrix();\n\tcamera.position.setFromSphericalCoords( orbit.radius, MathUtils.DEG2RAD * orbit.phi, MathUtils.DEG2RAD * orbit.theta );\n\n\t// initialize the canvas size\n\tconst { width, height } = dimensions;\n\trenderer.setSize( width, height );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\tcamera.aspect = width / height;\n\tcamera.fov = verticalFoV;\n\tcamera.updateProjectionMatrix();\n\tcontrols.update();\n\n\tawait pathTracer.setSceneAsync( scene, camera, {\n\t\tonProgress: v => {\n\n\t\t\tloader.setPercentage( 0.5 + 0.5 * v );\n\n\t\t}\n\t} );\n\n\tloader.setCredits( modelInfo.credit || '' );\n\tcontainerEl.style.display = 'flex';\n\tloadingModel = false;\n\n\tonParamsChange();\n\tbuildGui();\n\tupdateImage();\n\n}\n\nfunction updateImage() {\n\n\timgEl.src = `https://raw.githubusercontent.com/google/model-viewer/master/packages/render-fidelity-tools/test/goldens/${ params.model }/${ params.imageType }-golden.png`;\n\n}\n"],"names":["$f6c83a1fcfd19596$var$containerEl","$f6c83a1fcfd19596$var$imgEl","$f6c83a1fcfd19596$var$loader","$f6c83a1fcfd19596$var$gui","$f6c83a1fcfd19596$var$model","$f6c83a1fcfd19596$var$envMap","$f6c83a1fcfd19596$var$pathTracer","$f6c83a1fcfd19596$var$renderer","$f6c83a1fcfd19596$var$camera","$f6c83a1fcfd19596$var$scene","$f6c83a1fcfd19596$var$controls","$f6c83a1fcfd19596$var$modelDatabase","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","Map","baseUrl","manifest","i","length","path","resolved","URL","toString","$5ee05658f4b0e3bf$export$d076a711b55c758a","$ilwiq","DataTextureLoader","constructor","manager","type","HalfFloatType","parse","buffer","data","numElements","rgbe_error","rgbe_error_code","msg","fgets","lineLimit","consume","p","pos","len","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","slice","byteArray","Uint8Array","rgbe_header_info","RGBE_ReadHeader","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","w","h","image_rgba_data","RGBE_ReadPixels_RLE","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","off","FloatType","floatArray","Float32Array","j","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","scale","Math","pow","halfArray","RGBEByteToRGBHalf","DataUtils","toHalfFloat","min","setDataType","value","load","url","onLoad","onProgress","onError","texture","texData","colorSpace","LinearSRGBColorSpace","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","$465cbee6efe1dae1$var$isTypedArray","arr","ArrayBuffer","$465cbee6efe1dae1$export$c80603c061964928","ignoreKeys","Set","add","shareTextures","textures","materials","areEqual","objectA","objectB","keySet","traverseSet","traverse","a","b","has","aIsElement","Element","bIsElement","Image","src","aIsImageBitmap","ImageBitmap","bIsImageBitmap","equals","aIsTypedArray","bIsTypedArray","l","key","clear","hasOwnProperty","Function","keys","Array","from","values","result","delete","process","object","replaced","processMaterial","material","foundMaterial","otherMaterial","push","isTexture","image","foundTexture","c","isMesh","isArray","retained","$6171edc1778f11e8$export$3a05a7fb86d40d58","$hWj76","$hWds8","$RPVlj","$bHiTZ","$9wqOU","$5rCKZ","$6171edc1778f11e8$var$_resolution","Vector2","multipleImportanceSampling","Boolean","_pathTracer","defines","FEATURE_MIS","setDefine","transmissiveBounces","bounces","filterGlossyFactor","samples","target","tiles","renderer","_renderer","_generator","PathTracingSceneGenerator","PathTracingRenderer","_queueReset","_clock","Clock","_lowResPathTracer","_quad","FullScreenQuad","ClampedInterpolationMaterial","map","transparent","blending","NoBlending","premultipliedAlpha","getContextAttributes","_materials","renderDelay","minSamples","fadeDuration","enablePathTracing","pausePathTracing","dynamicLowRes","lowResScale","renderScale","synchronizeRenderSize","rasterizeScene","renderToCanvas","textureSize","rasterizeSceneCallback","scene","camera","render","renderToCanvasCallback","quad","currentAutoClear","autoClear","setScene","Scene","PerspectiveCamera","setBVHWorker","worker","options","updateMatrixWorld","generator","setObjects","_buildAsync","generateAsync","then","_updateFromResults","generate","setSceneAsync","args","setCamera","updateCamera","reset","updateMaterials","getTextures","setTextures","x","y","updateFrom","updateLights","lights","getLights","iesTextures","getIesTextures","iesProfiles","updateEnvironment","backgroundBlur","backgroundBlurriness","backgroundIntensity","backgroundRotation","makeRotationFromEuler","invert","background","backgroundMap","backgroundAlpha","isColor","_colorBackground","GradientEquirectTexture","colorBackground","topColor","bottomColor","update","environmentIntensity","environmentRotation","_previousEnvironment","environment","envMapInfo","results","geometry","bvh","bvhChanged","pathTracer","attributesArray","attributes","normal","tangent","uv","color","materialIndexAttribute","materialIndex","_previousScene","renderSample","lowResPathTracer","clock","_updateScale","opacity","start","delta","getDelta","elapsedTime","getElapsedTime","alpha","extensions","currentOpacity","AdditiveBlending","NormalBlending","dispose","_renderQuad","getDrawingBufferSize","floor","getSize","setSize","$88425f7125b6e46c$export$38d6a241e670a287","$dbdMq","$88425f7125b6e46c$var$_direction","Vector3","ProceduralEquirectTexture","resolution","Color","exponent","generationCallback","polar","coord","setFromSpherical","t","lerpColors","copy","other","$9986fde00d79bc96$export$ab88b3c5fea10066","$9986fde00d79bc96$var$_uv","$9986fde00d79bc96$var$_coord","$9986fde00d79bc96$var$_polar","Spherical","$9986fde00d79bc96$var$_color","DataTexture","RGBAFormat","EquirectangularReflectionMapping","RepeatWrapping","ClampToEdgeWrapping","needsUpdate","theta","PI","phi","radius","i4","r","g","$3f6d89af35c8e149$export$41f50d3add172b7d","ShaderMaterial","uniforms","params","vertexShader","fragmentShader","setValues","$edfd8156d2dff8d2$export$1369cce09af89668","$6KVZ3","$3ePKg","$cSOJe","$a8VBx","$5Gkg5","$edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT","navigator","hardwareConcurrency","$edfd8156d2dff8d2$var$_ParallelMeshBVHWorker","WorkerBase","Worker","name","maxWorkerCount","max","isSharedArrayBufferSupported","runTask","Promise","resolve","reject","index","indirect","ensureIndex","getAttribute","isInterleavedBufferAttribute","onerror","message","onmessage","error","serialized","position","MeshBVH","deserialize","setIndex","boundsOptions","setBoundingBox","array","newIndex","BufferAttribute","boundingBox","getBoundingBox","Box3","progress","postMessage","operation","convertToBufferType","SharedArrayBuffer","includedProgressCallback","groups","console","warn","GenerateMeshBVHWorker","$25bad171b6c71f9d$export$8dbf7c43841b75b7","running","promise","finally","terminate","$762755cd5891d020$export$426cc6213ad628cf","assign","transferable","filter","$7ryUf","$e82cb97686acadc5$var$url","origin","workerUrl","isESM","self","location","source","JSON","stringify","createObjectURL","Blob","$1ce6f7437f671131$var$url","$a399336cf50451da$var$_styleElement","$a399336cf50451da$export$c2252eb3bc5ad0b7","document","createElement","textContent","head","appendChild","container","classList","percentageEl","samplesEl","creditsEl","loaderBarEl","descriptionEl","_description","_loaderBar","_percentage","_credits","_samples","_container","setPercentage","attach","perc","style","innerText","toFixed","remove","setSamples","setCredits","credits","innerHTML","setDescription","description","$6bd4eb2914ee2835$export$f1ac3a587b6cbb5d","shader","$ba14a4aaa0cde19b$export$98323a006d35be35","$a21c9b4177584031$export$fe1d788deccfbee3","$60fb6dc3c6495c33$export$4c711108e2e8ef5e","$kp7Te","$891vQ","$7lx9d","$jiuw3","$62xhu","$8mHfG","$5Rd1x","$kqOCM","$e2Pv4","$f6c83a1fcfd19596$var$BASE_URL","$f6c83a1fcfd19596$var$urlParams","URLSearchParams","window","search","$f6c83a1fcfd19596$var$maxSamples","$f6c83a1fcfd19596$var$hideUI","$f6c83a1fcfd19596$var$params","enable","pause","acesToneMapping","devicePixelRatio","model","checkerboardTransparency","displayImage","imageMode","imageOpacity","imageType","$f6c83a1fcfd19596$var$loadingModel","$f6c83a1fcfd19596$var$delaySamples","$f6c83a1fcfd19596$var$onHashChange","hash","modelName","substring","replaceAll","$f6c83a1fcfd19596$var$updateModel","$f6c83a1fcfd19596$var$onParamsChange","renderSkybox","destroy","modelInfo","verticalFoV","lighting","orbit","dimensions","z","display","envUrl","modelUrl","replace","LoadingManager","envTexture","gltf","all","RGBELoader","loadAsync","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","total","loaded","mapping","reducer","MaterialReducer","targetsToDisconnect","isLight","forEach","removeFromParent","targetGroup","Group","box","sphere","Sphere","setFromObject","getBoundingSphere","near","far","updateProjectionMatrix","setFromSphericalCoords","MathUtils","DEG2RAD","setPixelRatio","aspect","fov","credit","$f6c83a1fcfd19596$var$buildGui","GUI","onChange","pathTracingFolder","addFolder","toneMapping","ACESFilmicToneMapping","NoToneMapping","comparisonFolder","$f6c83a1fcfd19596$var$updateImage","$f6c83a1fcfd19596$var$init","getElementById","querySelector","body","LoaderElement","WebGLRenderer","antialias","preserveDrawingBuffer","physicallyCorrectLights","setClearAlpha","domElement","WebGLPathTracer","ParallelMeshBVHWorker","innerWidth","innerHeight","OrbitControls","addEventListener","scenarios","fetch","res","json","$f6c83a1fcfd19596$var$animate","requestAnimationFrame","dispatchEvent","Event"],"version":3,"file":"viewerTest.daf0f9c0.js.map"}